
==================== FINAL INTERFACE ====================
2019-05-20 21:44:00.055173922 UTC

interface main:Runtime.RunCmd 8063
  interface hash: d102034be1c31bf09e572a017c5c2ef6
  ABI hash: 5571907718e5a61438ea5bddb779a85e
  export-list hash: 7fbcd3cff961e04b34a322cc02b01044
  orphan hash: daf233ce1954e2eaee64ecc4ad8df6d4
  flag hash: 0d573f0378d62f8692315b5e560c8adb
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Runtime.RunCmd.checkoutBranch
  Runtime.RunCmd.commitRoot
  Runtime.RunCmd.getDiff
  Runtime.RunCmd.initRepo
  Runtime.RunCmd.mkBranch
  Runtime.RunCmd.mkCommit
  Runtime.RunCmd.mkMergeCommit
  Runtime.RunCmd.printDiff
  Runtime.RunCmd.runCommand
  Runtime.RunCmd.setDirTo
  Runtime.RunCmd.status
module dependencies: Runtime.Capabilities Runtime.Commands
                     Runtime.FileIO Runtime.Types
package dependencies: RSA-2.3.1 SHA-1.6.4.4 StateVar-1.1.1.1
                      adjunctions-4.4 aeson-1.4.2.0 ansi-terminal-0.8.2
                      ansi-wl-pprint-0.6.8.2 array-0.5.3.0 asn1-encoding-0.9.5
                      asn1-parse-0.9.4 asn1-types-0.3.2 async-2.2.1 attoparsec-0.13.2.2
                      authenticate-oauth-1.6 base-4.12.0.0 base-compat-0.10.5
                      base-orphans-0.8 base16-bytestring-0.1.1.6
                      base64-bytestring-1.0.0.2 basement-0.0.10 bifunctors-5.5.3
                      binary-0.8.6.0 blaze-builder-0.4.1.0 bytestring-0.10.8.2
                      call-stack-0.1.0 case-insensitive-1.2.0.11 cereal-0.5.8.0
                      colour-2.3.4 comonad-5.0.4 connection-0.2.8 containers-0.6.0.1
                      contravariant-1.5 cookie-0.4.4 crypto-api-0.13.3
                      crypto-pubkey-types-0.4.3 cryptonite-0.25 data-default-0.7.1.1
                      data-default-class-0.1.2.0 data-default-instances-containers-0.0.1
                      data-default-instances-dlist-0.0.1
                      data-default-instances-old-locale-0.0.1 deepseq-1.4.4.0
                      deriving-compat-0.5.4 directory-1.3.3.0 distributive-0.6
                      dlist-0.8.0.5 entropy-0.4.1.4 exceptions-0.10.0 filepath-1.4.2.1
                      free-5.1 ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      hgit-0.1.0.0 hourglass-0.2.12 http-client-0.5.14
                      http-client-tls-0.3.5.3 http-types-0.12.2 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.2 kan-extensions-5.2 lens-4.17
                      lens-aeson-1.0.2 memory-0.14.18 merkle-schemes-0.1.0.0
                      merkle-schemes-ext-0.1.0.0 mime-types-0.1.0.9 mtl-2.2.2
                      network-2.8.0.0 network-uri-2.6.1.0 old-locale-1.0.0.7
                      optparse-applicative-0.14.3.0 parsec-3.1.13.0 pem-0.2.4
                      pretty-1.1.3.6 primitive-0.6.4.0 process-1.6.3.0 profunctors-5.3
                      random-1.1 recursion-schemes-5.1.1 reflection-2.1.4
                      safe-exceptions-0.1.7.0 scientific-0.3.6.2 semigroupoids-5.3.2
                      socks-0.5.6 stm-2.5.0.0 streaming-commons-0.2.1.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 th-abstraction-0.2.10.0
                      time-1.8.0.2 time-locale-compat-0.1.1.5 tls-1.4.1
                      transformers-0.5.5.0 transformers-base-0.4.5.2
                      transformers-compat-0.6.2 unix-2.7.2.2 unordered-containers-0.2.9.0
                      uuid-types-1.0.3 vector-0.12.0.2 wreq-0.5.3.1 x509-1.7.5
                      x509-store-1.6.7 x509-system-1.6.6 x509-validation-1.6.11
                      zlib-0.6.2
orphans: merkle-schemes-0.1.0.0:Data.Aeson.Orphans
         colour-2.3.4:Data.Colour lens-aeson-1.0.2:Data.Aeson.Lens
         data-default-instances-containers-0.0.1:Data.Default.Instances.Containers
         data-default-instances-dlist-0.0.1:Data.Default.Instances.DList
         data-default-instances-old-locale-0.0.1:Data.Default.Instances.OldLocale
         RSA-2.3.1:Codec.Crypto.RSA.Pure wreq-0.5.3.1:Network.Wreq.Types
         reflection-2.1.4:Data.Reflection
         http-client-0.5.14:Network.HTTP.Client.Request
         basement-0.0.10:Basement.UArray.Base basement-0.0.10:Basement.Block
         network-2.8.0.0:Network.Socket
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.2:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         vector-0.12.0.2:Data.Vector.Fusion.Bundle
         stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: adjunctions-4.4:Data.Functor.Rep
                         aeson-1.4.2.0:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         basement-0.0.10:Basement.Block.Base
                         basement-0.0.10:Basement.Bounded basement-0.0.10:Basement.Monad
                         basement-0.0.10:Basement.MutableBuilder
                         basement-0.0.10:Basement.Nat basement-0.0.10:Basement.NonEmpty
                         basement-0.0.10:Basement.Numerical.Subtractive
                         basement-0.0.10:Basement.PrimType basement-0.0.10:Basement.String
                         basement-0.0.10:Basement.String.Encoding.ASCII7
                         basement-0.0.10:Basement.String.Encoding.ISO_8859_1
                         basement-0.0.10:Basement.String.Encoding.UTF16
                         basement-0.0.10:Basement.String.Encoding.UTF32
                         basement-0.0.10:Basement.Types.OffsetSize
                         basement-0.0.10:Basement.UArray.Base
                         basement-0.0.10:Basement.UTF8.Base
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Fix
                         bifunctors-5.5.3:Data.Bifunctor.Flip
                         bifunctors-5.5.3:Data.Bifunctor.Join
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         bifunctors-5.5.3:Data.Bifunctor.Wrapped
                         containers-0.6.0.1:Data.Graph
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         cryptonite-0.25:Crypto.ECC cryptonite-0.25:Crypto.Error.Types
                         cryptonite-0.25:Crypto.Hash.Blake2
                         cryptonite-0.25:Crypto.Hash.Blake2b
                         cryptonite-0.25:Crypto.Hash.Blake2bp
                         cryptonite-0.25:Crypto.Hash.Blake2s
                         cryptonite-0.25:Crypto.Hash.Blake2sp
                         cryptonite-0.25:Crypto.Hash.Keccak cryptonite-0.25:Crypto.Hash.MD2
                         cryptonite-0.25:Crypto.Hash.MD4 cryptonite-0.25:Crypto.Hash.MD5
                         cryptonite-0.25:Crypto.Hash.RIPEMD160
                         cryptonite-0.25:Crypto.Hash.SHA1 cryptonite-0.25:Crypto.Hash.SHA224
                         cryptonite-0.25:Crypto.Hash.SHA256 cryptonite-0.25:Crypto.Hash.SHA3
                         cryptonite-0.25:Crypto.Hash.SHA384
                         cryptonite-0.25:Crypto.Hash.SHA512
                         cryptonite-0.25:Crypto.Hash.SHA512t
                         cryptonite-0.25:Crypto.Hash.SHAKE
                         cryptonite-0.25:Crypto.Hash.Skein256
                         cryptonite-0.25:Crypto.Hash.Skein512
                         cryptonite-0.25:Crypto.Hash.Tiger
                         cryptonite-0.25:Crypto.Hash.Whirlpool dlist-0.8.0.5:Data.DList
                         free-5.1:Control.Comonad.Cofree
                         free-5.1:Control.Comonad.Trans.Cofree free-5.1:Control.Monad.Free
                         free-5.1:Control.Monad.Trans.Free
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         hgit-0.1.0.0:HGit.Core.Types http-client-0.5.14:Network.HTTP.Client
                         kan-extensions-5.2:Data.Functor.Day
                         kan-extensions-5.2:Data.Functor.Yoneda lens-4.17:Control.Lens.At
                         lens-4.17:Control.Lens.Internal.Indexed
                         lens-4.17:Control.Lens.Reified lens-4.17:Control.Lens.Tuple
                         lens-4.17:Control.Lens.Wrapped lens-4.17:Control.Lens.Zoom
                         lens-aeson-1.0.2:Data.Aeson.Lens main:Runtime.Types
                         merkle-schemes-0.1.0.0:Merkle.Types.IPFS
                         network-uri-2.6.1.0:Network.URI
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         profunctors-5.3:Data.Profunctor.Composition
                         profunctors-5.3:Data.Profunctor.Rep
                         recursion-schemes-5.1.1:Data.Functor.Base
                         recursion-schemes-5.1.1:Data.Functor.Foldable
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         th-abstraction-0.2.10.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.2:Data.Vector vector-0.12.0.2:Data.Vector.Primitive
                         vector-0.12.0.2:Data.Vector.Storable
                         vector-0.12.0.2:Data.Vector.Unboxed
                         vector-0.12.0.2:Data.Vector.Unboxed.Base
                         zlib-0.6.2:Codec.Compression.Zlib.Stream
import  -/  base-4.12.0.0:Control.Monad.IO.Class e8f65a5571f64fe686cca3ac75a1aa0e
import  -/  base-4.12.0.0:Data.Either 946a3435d06773e1dbcad1ba5dc18a2c
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.List ce2c69da408fdc014383cede9e1f9adf
import  -/  base-4.12.0.0:Data.List.NonEmpty d9b99a249213afa9344e96f715fca047
import  -/  base-4.12.0.0:Data.OldList c2cab40fed7d27b5e717779f9a3c09ea
import  -/  base-4.12.0.0:Data.Traversable 257e9f3b6739f5bfbaaf0ac0abb0ddc5
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.IO edc9355d7dbab399fd5d385cd5bb457d
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  base-4.12.0.0:System.IO 88c2b1c4079c52d62ed362d4eb9a5302
import  -/  containers-0.6.0.1:Data.Map 4f92a276b97311a7619a6e03c8ca6ee3
import  -/  containers-0.6.0.1:Data.Map.Internal 7258cbfb7d1b897678a42b6739fc4dac
import  -/  directory-1.3.3.0:System.Directory 0f500eb353c86bec5fb4ae7b9d4e6507
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  hgit-0.1.0.0:HGit.Core.Diff 60a8e7f35e20c164ad244cb585ec2c4a
import  -/  hgit-0.1.0.0:HGit.Core.Merge f5ff2d91c98d1674c0cdaf0715bb1457
import  -/  hgit-0.1.0.0:HGit.Core.Types 79e907bf15f7ab56c84aba27eb2d3ddb
import  -/  Runtime.Capabilities 27549094e78df9f7af431ec023777ab6
  exports: 40f7120a5ece4cdaee8d81f0d3967551
  RepoCaps 1f275b17e52edb0bdff76891706d6bb9
  _blobStore 4552707e66bae1e40786b903a7ed2ef7
  _commitStore 4552707e66bae1e40786b903a7ed2ef7
  _dirStore 4552707e66bae1e40786b903a7ed2ef7
  getBranch bcbaa44b5db3ece0e851dc807ab59a4b
  rcBaseDir 1f275b17e52edb0bdff76891706d6bb9
  rcState 1f275b17e52edb0bdff76891706d6bb9
  rcStore 1f275b17e52edb0bdff76891706d6bb9
  writeState 97a141d96b135681a392cec9201607bd
import  -/  Runtime.Commands b6c5de75f4557f872e827c2d9ff81a00
  exports: ddf5af81328c4defe5ed0e9877790537
  CheckoutBranch 71db92f7ee0f6e3a460f648ba65db685
  GetDiff 6766ba11f8b4a7450ad17403bf174df8
  GetStatus c45ead124614d9836635a1cfefb75542
  MkBranch d4fc768b9e696b5e0990f32d23fb6ea6
  MkCommit c2f9232a58927f720fe03276419999c1
  MkMergeCommit b0318269b785e2f25c4552d9be81b54d
  RepoCommand 2dc75d94311310c7146e504a037632e1
import  -/  Runtime.FileIO 8f4c25d6cf35785e714aa5fb5b19318e
  exports: d80ecce8ef241aa482f66becde486972
  readTree e4b796f592fed95b81b87396e94855ae
  writeTree fd43698b89feaf39e8f98e8e6980dae6
import  -/  Runtime.Types 8992a00702318e65c5fabfade03c19fa
  exports: c69cf15791bec2cf3135d9b0db2121c6
  RepoState dd587e5b3aa12f6942a059e6733288f6
  branches dd587e5b3aa12f6942a059e6733288f6
  currentBranch dd587e5b3aa12f6942a059e6733288f6
  initialRepoState 52e67e91d57a6dd4a9753ccfb02db0ef
import  -/  merkle-schemes-0.1.0.0:Data.Aeson.Orphans 73759998819a6d93c00c4e8c1858aa59
import  -/  merkle-schemes-0.1.0.0:Merkle.Functors eb8956b10d3f8e04ccb8a7a2b5cc8ff0
import  -/  merkle-schemes-0.1.0.0:Merkle.Store e36594001decc0fe1d4e174b93d02572
import  -/  merkle-schemes-0.1.0.0:Merkle.Store.Deref ff403763285cbb166ee13c8decbea694
import  -/  merkle-schemes-0.1.0.0:Util.RecursionSchemes b224bcde365e2dc1dc7460c2c5e1f79a
import  -/  merkle-schemes-ext-0.1.0.0:Merkle.Store.IPFS f31cc191599763028ee09446484660d4
import  -/  mtl-2.2.2:Control.Monad.Reader d851fb94eb94072f491282515418f996
import  -/  mtl-2.2.2:Control.Monad.Reader.Class bfd53ec9164fa16880d07775c83c6ec0
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Class f3e62b8b4b5be304a48413d1f1e4625e
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 3d5c6b0df34d74144ad9d24efee0de98
e128bd6e74a27f8780e04ae95982f935
  $s$fApplicativeReaderT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
                  (Runtime.RunCmd.$s$fApplicativeReaderT_$s$fFunctorReaderT @ r)
                  (\ @ a (x :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, x #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                      <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)))
                  (Runtime.RunCmd.$s$fApplicativeReaderT_$s$fApplicativeReaderT_$c<*>
                     @ r)
                  (Control.Monad.Trans.Reader.$fApplicativeReaderT_$cliftA2
                     @ GHC.Types.IO
                     @ r
                     GHC.Base.$fApplicativeIO)
                  (Runtime.RunCmd.$s$fApplicativeReaderT_$s$fApplicativeReaderT_$c*>
                     @ r)
                  (Runtime.RunCmd.$s$fApplicativeReaderT_$s$fApplicativeReaderT_$c<*
                     @ r) -}
07421820f84ed42eec2871c4a02fe354
  $s$fApplicativeReaderT_$s$fApplicativeReaderT_$c*> ::
    Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,A)))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a)
                   (v :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (u `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)
                         r1)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (v `cast`
                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                       <Type>_N <r>_R <GHC.Types.IO>_R <b>_N)
                    r1)
                   `cast`
                 (GHC.Types.N:IO[0] <b>_R)
                   ipv })
                  `cast`
                (forall (r :: <Type>_N) (a :: <Type>_N) (b :: <Type>_N).
                 <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                        <Type>_N <r>_R <GHC.Types.IO>_R <b>_N)) -}
337ea9ac140105fca6fb85da9932f55f
  $s$fApplicativeReaderT_$s$fApplicativeReaderT_$c<* ::
    Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,U)))><L,1*C1(C1(U(U,A)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (u :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a)
                   (v :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (u `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)
                         r1)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 case (v `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N <r>_R <GHC.Types.IO>_R <b>_N)
                         r1)
                        `cast`
                      (GHC.Types.N:IO[0] <b>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 (# ipv2, ipv1 #) } })
                  `cast`
                (forall (r :: <Type>_N) (a :: <Type>_N) (b :: <Type>_N).
                 <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <a>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                        <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)) -}
6bb0e66c2f0d7f64b84a58a254e07440
  $s$fApplicativeReaderT_$s$fApplicativeReaderT_$c<*> ::
    Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,1*C1(U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (f :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO (a -> b))
                   (v :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (f `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N <r>_R <GHC.Types.IO>_R <a -> b>_N)
                         r1)
                        `cast`
                      (GHC.Types.N:IO[0] <a -> b>_R)
                        s of ds { (#,#) ipv ipv1 ->
                 case (v `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)
                         r1)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 (# ipv2, ipv1 ipv3 #) } })
                  `cast`
                (forall (r :: <Type>_N) (a :: <Type>_N) (b :: <Type>_N).
                 <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO (a -> b)>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                        <Type>_N <r>_R <GHC.Types.IO>_R <b>_N)) -}
2796f53f39048fddaf6f5387b03e17ef
  $s$fApplicativeReaderT_$s$fFunctorReaderT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
                  (Runtime.RunCmd.$s$fApplicativeReaderT_$s$fFunctorReaderT_$cfmap
                     @ r)
                  (Runtime.RunCmd.$s$fApplicativeReaderT_$s$fFunctorReaderT_$c<$
                     @ r) -}
82060f103b47951c16533f8db3a3fd1a
  $s$fApplicativeReaderT_$s$fFunctorReaderT_$c<$ ::
    a
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><C(C(S(SL))),1*C1(C1(U(U,A)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (x :: a)
                   (v :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b)
                   (x1 :: r)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (v `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N <r>_R <GHC.Types.IO>_R <b>_N)
                         x1)
                        `cast`
                      (GHC.Types.N:IO[0] <b>_R)
                        eta1 of ds { (#,#) ipv ipv1 ->
                 (# ipv, x #) })
                  `cast`
                (forall (r :: <Type>_N) (a :: <Type>_N) (b :: <Type>_N).
                 <a>_R
                 ->_R <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <a>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                        <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)) -}
9bf99da5092d5a628149a2c74810b4fb
  $s$fApplicativeReaderT_$s$fFunctorReaderT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(S(SL))),1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Reader.mapReaderT
                   @ Type
                   @ Type
                   @ GHC.Types.IO
                   @ a
                   @ GHC.Types.IO
                   @ b
                   @ r
                   (GHC.Base.$fFunctorIO2 @ a @ b f)
                     `cast`
                   (<GHC.Types.IO a>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R))) -}
1ed94c5ef852704a4b56d1c00b874896
  $s$fEqConst ::
    forall k (b :: k).
    GHC.Classes.Eq
      (Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ k @ b :: k.
                  @ (Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b)
                  Data.Text.$fEqText_$c==
                    `cast`
                  ((Sym (Merkle.Types.IPFS.N:RawIPFSHash[0]) ; Sym (Data.Functor.Const.N:Const[0]
                                                                        <k>_N
                                                                        <Merkle.Types.IPFS.RawIPFSHash>_R
                                                                        <b>_P))
                   ->_R (Sym (Merkle.Types.IPFS.N:RawIPFSHash[0]) ; Sym (Data.Functor.Const.N:Const[0]
                                                                             <k>_N
                                                                             <Merkle.Types.IPFS.RawIPFSHash>_R
                                                                             <b>_P))
                   ->_R <GHC.Types.Bool>_R)
                  Data.Text.$fEqText_$c/=
                    `cast`
                  ((Sym (Merkle.Types.IPFS.N:RawIPFSHash[0]) ; Sym (Data.Functor.Const.N:Const[0]
                                                                        <k>_N
                                                                        <Merkle.Types.IPFS.RawIPFSHash>_R
                                                                        <b>_P))
                   ->_R (Sym (Merkle.Types.IPFS.N:RawIPFSHash[0]) ; Sym (Data.Functor.Const.N:Const[0]
                                                                             <k>_N
                                                                             <Merkle.Types.IPFS.RawIPFSHash>_R
                                                                             <b>_P))
                   ->_R <GHC.Types.Bool>_R) -}
30e369ff21e8302b3aa9eff95039a273
  $s$fMonadIOReaderT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
                  (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT @ r)
                  (\ @ a (x :: GHC.Types.IO a) (ds :: r) -> x)
                    `cast`
                  (forall (a :: <Type>_N).
                   <GHC.Types.IO a>_R
                   ->_R Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)) -}
2c5f3c0d85dce8f89f07068368d47270
  $s$fMonadIOReaderT_$s$fMonadReaderT ::
    GHC.Base.Monad (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
                  (Runtime.RunCmd.$s$fApplicativeReaderT @ r)
                  (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT_$c>>= @ r)
                  (Runtime.RunCmd.$s$fApplicativeReaderT_$s$fApplicativeReaderT_$c*>
                     @ r)
                  (\ @ a (eta :: a) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1 -}
                     = \ (s :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s, eta #)
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                      <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)))
                  (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT_$cfail @ r) -}
654fb3a7cd6143c8d56594750d20cfef
  $s$fMonadIOReaderT_$s$fMonadReaderT_$c>>= ::
    Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
    -> (a -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b)
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SL))),1*C1(C1(U(U,U)))><L,1*C1(C1(C1(U(U,U))))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a)
                   (k :: a -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b)
                   (r1 :: r)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m1
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N <r>_R <GHC.Types.IO>_R <a>_N)
                         r1)
                        `cast`
                      (GHC.Types.N:IO[0] <a>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 ((k ipv1)
                    `cast`
                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                       <Type>_N <r>_R <GHC.Types.IO>_R <b>_N)
                    r1)
                   `cast`
                 (GHC.Types.N:IO[0] <b>_R)
                   ipv })
                  `cast`
                (forall (r :: <Type>_N) (a :: <Type>_N) (b :: <Type>_N).
                 <Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a>_R
                 ->_R <a -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO b>_R
                 ->_R (<r>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <b>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                        <Type>_N <r>_R <GHC.Types.IO>_R <b>_N)) -}
681fa58d475a8988ed5d68fa38cfab4f
  $s$fMonadIOReaderT_$s$fMonadReaderT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO a
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ r @ a (msg :: GHC.Base.String) ->
                 let {
                   m1 :: GHC.Types.IO a
                   = GHC.Magic.noinline
                       @ (forall a1. [GHC.Types.Char] -> GHC.Types.IO a1)
                       GHC.IO.failIO1
                         `cast`
                       (forall (a1 :: <Type>_N).
                        <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a1>_R))
                       @ a
                       msg
                 } in
                 (\ (ds :: r) -> m1)
                   `cast`
                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                           <Type>_N <r>_R <GHC.Types.IO>_R <a>_N))) -}
5094a6cc1a8cf8686f63dd0a87620e88
  $s$fMonadThrowReaderT ::
    Control.Monad.Catch.MonadThrow
      (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r.
                  @ (Control.Monad.Trans.Reader.ReaderT r GHC.Types.IO)
                  (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT @ r)
                  (\ @ e @ a (eta :: GHC.Exception.Type.Exception e) (eta1 :: e) ->
                   let {
                     m1 :: GHC.Prim.State# GHC.Prim.RealWorld
                           -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                       {- Arity: 1, Strictness: <L,U>x -}
                     = GHC.IO.throwIO1 @ e @ a eta eta1
                   } in
                   (\ (ds :: r) -> m1)
                     `cast`
                   ((<r>_R
                     ->_R Sym (GHC.Types.N:IO[0]
                                   <a>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                      <Type>_N <r>_R <GHC.Types.IO>_R <a>_N))) -}
37cf764b1f5c03c6538e6681085c83ba
  $s$fToJSONConst_$s$fToJSONConst_$ctoJSON ::
    forall k (b :: k).
    Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>m3,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ k
                   @ b :: k
                   (ds :: Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b) ->
                 Data.Aeson.Types.Internal.$WString
                   ds
                     `cast`
                   (Data.Functor.Const.N:Const[0]
                        <k>_N
                        <Merkle.Types.IPFS.RawIPFSHash>_R
                        <b>_P ; Merkle.Types.IPFS.N:RawIPFSHash[0])) -}
1d9a97ec5b2b6452e42f1a355d3d1c4d
  $s$fToJSONf ::
    Data.Aeson.Types.ToJSON.ToJSON
      (HGit.Core.Types.Commit
         (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
         (Data.Functor.Const.Const
            Merkle.Types.IPFS.RawIPFSHash
            (HGit.Core.Types.Commit
               (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (HGit.Core.Types.Commit
                       (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash
                          (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))))
                  (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash
                          (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                     (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                        @ (Type -> Type)
                        @ (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                     (\ (x :: [Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash
                                 (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                      Data.Aeson.Types.Internal.$WArray
                        (Data.Vector.Generic.new
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Generic.New.unstream
                              @ Data.Vector.Vector
                              @ Data.Aeson.Types.Internal.Value
                              (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                              (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                 @ Data.Vector.Fusion.Util.Id
                                 @ Data.Aeson.Types.Internal.Value
                                 @ Data.Vector.Vector
                                 Data.Vector.Fusion.Util.$fMonadId
                                 Data.Vector.Fusion.Bundle.Size.Unknown
                                 (GHC.Base.build
                                    @ Data.Aeson.Types.Internal.Value
                                    (\ @ b1
                                       (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                       (n1 :: b1)[OneShot] ->
                                     GHC.Base.foldr
                                       @ (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash
                                            (HGit.Core.Types.Commit
                                               (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                       @ b1
                                       (GHC.Base.mapFB
                                          @ Data.Aeson.Types.Internal.Value
                                          @ b1
                                          @ (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash
                                               (HGit.Core.Types.Commit
                                                  (HGit.Core.Types.Hash
                                                     HGit.Core.Types.HashableDir)))
                                          c
                                          (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                             @ (Type -> Type)
                                             @ (HGit.Core.Types.Commit
                                                  (HGit.Core.Types.Hash
                                                     HGit.Core.Types.HashableDir))))
                                       n1
                                       x)))))))
                  (let {
                     g :: [Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash
                             (HGit.Core.Types.Commit
                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]
                          -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash
                                  (HGit.Core.Types.Commit
                                     (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir)))
                                           c
                                           (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir))))
                                        n1
                                        x)))))
                   } in
                   (\ (x :: HGit.Core.Types.Commit
                              (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash
                                 (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))) ->
                    Data.Aeson.Encoding.Builder.encodeToBuilder
                      (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash
                              (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                         (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                         g
                         x))
                     `cast`
                   (<HGit.Core.Types.Commit
                       (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash
                          (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))>_R
                    ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                  <Data.Aeson.Types.Internal.Value>_P)))
                  (let {
                     f5 :: [Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash
                              (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash
                                  (HGit.Core.Types.Commit
                                     (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir)))
                                           c
                                           (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir))))
                                        n1
                                        x)))))
                   } in
                   let {
                     f1 :: HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                             (Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash
                                (HGit.Core.Types.Commit
                                   (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash
                              (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                         (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                         f5
                   } in
                   \ (x :: [HGit.Core.Types.Commit
                              (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash
                                 (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))]) ->
                   Data.Aeson.Types.Internal.$WArray
                     (Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n1 :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ (HGit.Core.Types.Commit
                                         (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                                         (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash
                                            (HGit.Core.Types.Commit
                                               (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))))
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ (HGit.Core.Types.Commit
                                            (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                                            (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash
                                               (HGit.Core.Types.Commit
                                                  (HGit.Core.Types.Hash
                                                     HGit.Core.Types.HashableDir))))
                                       c
                                       f1)
                                    n1
                                    x))))))
                  (Data.Aeson.Encoding.Internal.list
                     @ (HGit.Core.Types.Commit
                          (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash
                             (HGit.Core.Types.Commit
                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))))
                     (let {
                        g :: [Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash
                                (HGit.Core.Types.Commit
                                   (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]
                             -> Data.Aeson.Types.Internal.Value
                          {- Arity: 1 -}
                        = \ (x :: [Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash
                                     (HGit.Core.Types.Commit
                                        (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                          Data.Aeson.Types.Internal.$WArray
                            (Data.Vector.Generic.new
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Generic.New.unstream
                                  @ Data.Vector.Vector
                                  @ Data.Aeson.Types.Internal.Value
                                  (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                                  (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                     @ Data.Vector.Fusion.Util.Id
                                     @ Data.Aeson.Types.Internal.Value
                                     @ Data.Vector.Vector
                                     Data.Vector.Fusion.Util.$fMonadId
                                     Data.Vector.Fusion.Bundle.Size.Unknown
                                     (GHC.Base.build
                                        @ Data.Aeson.Types.Internal.Value
                                        (\ @ b1
                                           (c :: Data.Aeson.Types.Internal.Value
                                                 -> b1 -> b1)[OneShot]
                                           (n1 :: b1)[OneShot] ->
                                         GHC.Base.foldr
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir)))
                                           @ b1
                                           (GHC.Base.mapFB
                                              @ Data.Aeson.Types.Internal.Value
                                              @ b1
                                              @ (Data.Functor.Const.Const
                                                   Merkle.Types.IPFS.RawIPFSHash
                                                   (HGit.Core.Types.Commit
                                                      (HGit.Core.Types.Hash
                                                         HGit.Core.Types.HashableDir)))
                                              c
                                              (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                                 @ (Type -> Type)
                                                 @ (HGit.Core.Types.Commit
                                                      (HGit.Core.Types.Hash
                                                         HGit.Core.Types.HashableDir))))
                                           n1
                                           x)))))
                      } in
                      (\ (x :: HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                                 (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash
                                    (HGit.Core.Types.Commit
                                       (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))) ->
                       Data.Aeson.Encoding.Builder.encodeToBuilder
                         (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                            @ (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash
                                 (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                            (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                               @ (Type -> Type)
                               @ (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                            g
                            x))
                        `cast`
                      (<HGit.Core.Types.Commit
                          (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash
                             (HGit.Core.Types.Commit
                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))>_R
                       ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                     <Data.Aeson.Types.Internal.Value>_P)))) -}
c50c5aa7cd99639d40fa3ef23e19676c
  $s$fToJSONf_$ctoJSON ::
    HGit.Core.Types.Commit
      (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
      (Data.Functor.Const.Const
         Merkle.Types.IPFS.RawIPFSHash
         (HGit.Core.Types.Commit
            (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1,
     Unfolding: InlineRule (0, True, False)
                (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                   @ (Data.Functor.Const.Const
                        Merkle.Types.IPFS.RawIPFSHash
                        (HGit.Core.Types.Commit
                           (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                   (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                      @ (Type -> Type)
                      @ (HGit.Core.Types.Commit
                           (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                   (\ (x :: [Data.Functor.Const.Const
                               Merkle.Types.IPFS.RawIPFSHash
                               (HGit.Core.Types.Commit
                                  (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                    Data.Aeson.Types.Internal.$WArray
                      (Data.Vector.Generic.new
                         @ Data.Vector.Vector
                         @ Data.Aeson.Types.Internal.Value
                         (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                         (Data.Vector.Generic.New.unstream
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                               @ Data.Vector.Fusion.Util.Id
                               @ Data.Aeson.Types.Internal.Value
                               @ Data.Vector.Vector
                               Data.Vector.Fusion.Util.$fMonadId
                               Data.Vector.Fusion.Bundle.Size.Unknown
                               (GHC.Base.build
                                  @ Data.Aeson.Types.Internal.Value
                                  (\ @ b1
                                     (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                     (n1 :: b1)[OneShot] ->
                                   GHC.Base.foldr
                                     @ (Data.Functor.Const.Const
                                          Merkle.Types.IPFS.RawIPFSHash
                                          (HGit.Core.Types.Commit
                                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                     @ b1
                                     (GHC.Base.mapFB
                                        @ Data.Aeson.Types.Internal.Value
                                        @ b1
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                        c
                                        (Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                           @ (Type -> Type)
                                           @ (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash
                                                   HGit.Core.Types.HashableDir))))
                                     n1
                                     x))))))) -}
86bb94ab385b4b461e25c1fb376f7158
  $sinsert_$sgo13 ::
    HGit.Core.Types.BranchName
    -> HGit.Core.Types.BranchName
    -> a1
    -> Data.Map.Internal.Map HGit.Core.Types.BranchName a1
    -> Data.Map.Internal.Map HGit.Core.Types.BranchName a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
9c8e7cad8a520611864f6b427b4532f2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Runtime.RunCmd.$trModule3
                   Runtime.RunCmd.$trModule1) -}
068de1b11421e7cdae451ef9b26aafd5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Runtime.RunCmd.$trModule2) -}
bdc2766795360635cdbe9d6e04ab0f5d
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Runtime.RunCmd"#) -}
611f9d69e10dafb76cfaae371ecff199
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Runtime.RunCmd.$trModule4) -}
23b62cc3cf19af9080684ec72c888000
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
ea192f5cf4b5284272c1f75cb1aae367
  $w$sprintDiff ::
    [GHC.IO.FilePath]
    -> HGit.Core.Diff.Diff
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: [GHC.IO.FilePath])
                   (ww1 :: HGit.Core.Diff.Diff)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (GHC.IO.Handle.Text.hPutStr'
                    GHC.IO.Handle.FD.stdout
                    (GHC.CString.unpackAppendCString#
                       Runtime.RunCmd.printDiff5
                       (let {
                          n :: [GHC.Types.Char]
                          = GHC.CString.unpackAppendCString#
                              Runtime.RunCmd.printDiff4
                              (case ww of wild {
                                 [] -> GHC.Types.[] @ GHC.Types.Char
                                 : x xs1
                                 -> Data.OldList.intercalate_$spoly_go
                                      @ GHC.Types.Char
                                      x
                                      (Data.OldList.prependToAll
                                         @ [GHC.Types.Char]
                                         Runtime.RunCmd.printDiff2
                                         xs1) })
                        } in
                        case ww1 of wild {
                          HGit.Core.Diff.FileModified
                          -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff9 n
                          HGit.Core.Diff.FileReplacedWithDir
                          -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff7 n
                          HGit.Core.Diff.DirReplacedWithFile
                          -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff5 n
                          HGit.Core.Diff.EntityDeleted
                          -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff3 n
                          HGit.Core.Diff.EntityCreated
                          -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff1 n }))
                    GHC.Types.True)
                   `cast`
                 (GHC.Types.N:IO[0] <()>_R)
                   w) -}
3e78f18c190efd5eed1959d2b3edeed2
  $wc ::
    HGit.Core.Types.Blob
      (Data.Functor.Foldable.Fix
         (Data.Functor.Compose.Compose
            (Merkle.Functors.HashAnnotated
               Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
            HGit.Core.Types.Blob))
    -> HGit.Core.Types.Blob
         (Data.Functor.Foldable.Fix HGit.Core.Types.Blob)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
bd9366fd2ddf48d1f9fc8150f110925f
  $wcheckoutBranch ::
    HGit.Core.Types.BranchName
    -> HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.Blob
    -> HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.HashableDir
    -> (Merkle.Types.Hash
          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit
        -> GHC.Types.IO
             (GHC.Maybe.Maybe
                (Merkle.Store.DerefRes
                   Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)))
    -> Merkle.Store.PutCapability
         GHC.Types.IO
         Merkle.Types.IPFS.RawIPFSHash
         HGit.Core.Types.HashableCommit
    -> Data.Map.Internal.Map
         HGit.Core.Types.BranchName
         (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
    -> HGit.Core.Types.BranchName
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 9,
     Strictness: <S,U><L,U(U(U),U(U))><L,U(U(U),U(U))><C(C(S(SS))),U><L,U><S,U><L,U><L,U><S,U>,
     Inline: [2] -}
b8de184b976672c944802629900d02bc
  $wcommitRoot ::
    GHC.Base.Applicative m =>
    (forall a. GHC.Base.String -> m a)
    -> HGit.Core.Types.HashableCommit x
    -> m (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
  {- Arity: 3,
     Strictness: <L,1*U(A,1*C1(U),A,A,A,A)><L,1*C1(U)><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ m :: Type -> Type
                   @ x
                   (ww :: GHC.Base.Applicative m)
                   (ww1 :: forall a. GHC.Base.String -> m a)
                   (w :: HGit.Core.Types.HashableCommit x) ->
                 case w of wild {
                   HGit.Core.Types.NullCommit
                   -> ww1
                        @ (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                        Runtime.RunCmd.commitRoot2
                   HGit.Core.Types.Commit ds x1 ds1
                   -> GHC.Base.pure
                        @ m
                        ww
                        @ (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                        x1 }) -}
08cf35b093cdd1eb778eea2f73dd4090
  $wgetDiff ::
    HGit.Core.Types.BranchName
    -> HGit.Core.Types.BranchName
    -> HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.Blob
    -> HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.HashableDir
    -> (Merkle.Types.Hash
          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit
        -> GHC.Types.IO
             (GHC.Maybe.Maybe
                (Merkle.Store.DerefRes
                   Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)))
    -> Merkle.Store.PutCapability
         GHC.Types.IO
         Merkle.Types.IPFS.RawIPFSHash
         HGit.Core.Types.HashableCommit
    -> Data.Map.Internal.Map
         HGit.Core.Types.BranchName
         (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
    -> HGit.Core.Types.BranchName
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 10,
     Strictness: <S,U><L,U><L,U><L,U(U(U),U)><C(C(S(SS))),U><L,U><S,U><L,U><L,U><S,U>,
     Inline: [2] -}
7f604e60b350d1d6ea544b0a018ca7c4
  $winitRepo ::
    GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U(U)><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Types.Int)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Merkle.Store.IPFS.$wputForHash
                        @ (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                        Runtime.RunCmd.$s$fToJSONf
                        HGit.Core.Types.$fExtractKeysCommit_$cextractRawKeys
                          `cast`
                        (Sym (Merkle.Types.IPFS.N:ExtractKeys[0]
                                  <HGit.Core.Types.HashableCommit>_N))
                        ww
                        ww1
                        (HGit.Core.Types.NullCommit
                           @ (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                           @ (HGit.Core.Types.Hash
                                (HGit.Core.Types.Commit
                                   (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))))
                        w of ds1 { (#,#) ipv ipv1 ->
                 case System.IO.Error.modifyIOError1
                        @ GHC.IO.FilePath
                        System.Directory.getCurrentDirectory6
                        System.Directory.getCurrentDirectory2
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GHC.IO.FilePath>_R))
                        ipv of ds { (#,#) ipv2 ipv3 ->
                 let {
                   w2 :: Data.Map.Internal.Map
                           [GHC.Types.Char]
                           (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                   = Runtime.Types.$sfromList
                       @ (Data.Functor.Const.Const
                            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                       (GHC.Types.:
                          @ (HGit.Core.Types.BranchName,
                             HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
                          (Runtime.Types.initialRepoState_initial, ipv1)
                          (GHC.Types.[]
                             @ (HGit.Core.Types.BranchName,
                                HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)))
                 } in
                 let {
                   w3 :: Runtime.Types.RepoState
                   = Runtime.Types.RepoState w2 Runtime.Types.initialRepoState_initial
                 } in
                 let {
                   lvl40 :: GHC.IO.Handle.Types.Handle
                            -> GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     {- Arity: 2, Strictness: <L,U><S,U>,
                        Unfolding: InlineRule (2, True, False)
                                   (\ (ds2 :: GHC.IO.Handle.Types.Handle)[OneShot]
                                      (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                    Data.ByteString.Lazy.appendFile2
                                      ds2
                                      (Data.ByteString.Builder.toLazyByteString
                                         (Runtime.Types.$fToJSONRepoState1 w3)
                                           `cast`
                                         (Nth:3
                                              (((Sym (GHC.Generics.N:M1[0]
                                                          <Type>_N
                                                          <GHC.Generics.C>_P
                                                          <'GHC.Generics.MetaCons
                                                             "RepoState"
                                                             'GHC.Generics.PrefixI
                                                             'GHC.Types.True>_P
                                                          <GHC.Generics.S1
                                                             ('GHC.Generics.MetaSel
                                                                ('GHC.Maybe.Just "branches")
                                                                'GHC.Generics.NoSourceUnpackedness
                                                                'GHC.Generics.NoSourceStrictness
                                                                'GHC.Generics.DecidedLazy)
                                                             (GHC.Generics.Rec0
                                                                (Data.Map.Internal.Map
                                                                   HGit.Core.Types.BranchName
                                                                   (HGit.Core.Types.Hash
                                                                      HGit.Core.Types.HashableCommit)))
                                                           GHC.Generics.:*: GHC.Generics.S1
                                                                              ('GHC.Generics.MetaSel
                                                                                 ('GHC.Maybe.Just
                                                                                    "currentBranch")
                                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                                 'GHC.Generics.NoSourceStrictness
                                                                                 'GHC.Generics.DecidedLazy)
                                                                              (GHC.Generics.Rec0
                                                                                 HGit.Core.Types.BranchName)>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                                                                            <Type>_N
                                                                                                                            <GHC.Generics.D>_P
                                                                                                                            <'GHC.Generics.MetaData
                                                                                                                               "RepoState"
                                                                                                                               "Runtime.Types"
                                                                                                                               "main"
                                                                                                                               'GHC.Types.False>_P
                                                                                                                            <GHC.Generics.M1
                                                                                                                               GHC.Generics.C
                                                                                                                               ('GHC.Generics.MetaCons
                                                                                                                                  "RepoState"
                                                                                                                                  'GHC.Generics.PrefixI
                                                                                                                                  'GHC.Types.True)
                                                                                                                               (GHC.Generics.S1
                                                                                                                                  ('GHC.Generics.MetaSel
                                                                                                                                     ('GHC.Maybe.Just
                                                                                                                                        "branches")
                                                                                                                                     'GHC.Generics.NoSourceUnpackedness
                                                                                                                                     'GHC.Generics.NoSourceStrictness
                                                                                                                                     'GHC.Generics.DecidedLazy)
                                                                                                                                  (GHC.Generics.Rec0
                                                                                                                                     (Data.Map.Internal.Map
                                                                                                                                        HGit.Core.Types.BranchName
                                                                                                                                        (HGit.Core.Types.Hash
                                                                                                                                           HGit.Core.Types.HashableCommit)))
                                                                                                                                GHC.Generics.:*: GHC.Generics.S1
                                                                                                                                                   ('GHC.Generics.MetaSel
                                                                                                                                                      ('GHC.Maybe.Just
                                                                                                                                                         "currentBranch")
                                                                                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                      'GHC.Generics.NoSourceStrictness
                                                                                                                                                      'GHC.Generics.DecidedLazy)
                                                                                                                                                   (GHC.Generics.Rec0
                                                                                                                                                      HGit.Core.Types.BranchName))>_R)) <GHC.Types.Any>_N
                                                ->_R Sym (Data.ByteString.Builder.Internal.N:Builder[0]) ; Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                                                                                    <Data.Aeson.Types.Internal.Value>_P)) ; Nth:3
                                                                                                                                                                (Nth:3
                                                                                                                                                                     (<Data.Aeson.Types.Internal.Options>_R
                                                                                                                                                                      ->_R <Data.Aeson.Types.ToJSON.ToArgs
                                                                                                                                                                              Data.Aeson.Encoding.Internal.Encoding
                                                                                                                                                                              Data.Aeson.Types.Generic.Zero
                                                                                                                                                                              GHC.Types.Any>_R
                                                                                                                                                                      ->_R Sub (Sym (Runtime.Types.Rep_RepoState[0])) <GHC.Types.Any>_N
                                                                                                                                                                      ->_R <Data.Aeson.Encoding.Internal.Encoding>_R))) ; Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                                                                                                                                                                                              <Data.Aeson.Types.Internal.Value>_P))
                                      eta1) -}
                   = \ (ds2 :: GHC.IO.Handle.Types.Handle)[OneShot]
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                     Data.ByteString.Lazy.appendFile2
                       ds2
                       (Data.ByteString.Builder.toLazyByteString
                          (Runtime.Types.$fToJSONRepoState1 w3)
                            `cast`
                          (Nth:3
                               (((Sym (GHC.Generics.N:M1[0]
                                           <Type>_N
                                           <GHC.Generics.C>_P
                                           <'GHC.Generics.MetaCons
                                              "RepoState" 'GHC.Generics.PrefixI 'GHC.Types.True>_P
                                           <GHC.Generics.S1
                                              ('GHC.Generics.MetaSel
                                                 ('GHC.Maybe.Just "branches")
                                                 'GHC.Generics.NoSourceUnpackedness
                                                 'GHC.Generics.NoSourceStrictness
                                                 'GHC.Generics.DecidedLazy)
                                              (GHC.Generics.Rec0
                                                 (Data.Map.Internal.Map
                                                    HGit.Core.Types.BranchName
                                                    (HGit.Core.Types.Hash
                                                       HGit.Core.Types.HashableCommit)))
                                            GHC.Generics.:*: GHC.Generics.S1
                                                               ('GHC.Generics.MetaSel
                                                                  ('GHC.Maybe.Just "currentBranch")
                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                  'GHC.Generics.NoSourceStrictness
                                                                  'GHC.Generics.DecidedLazy)
                                                               (GHC.Generics.Rec0
                                                                  HGit.Core.Types.BranchName)>_R) ; Sym (GHC.Generics.N:M1[0]
                                                                                                             <Type>_N
                                                                                                             <GHC.Generics.D>_P
                                                                                                             <'GHC.Generics.MetaData
                                                                                                                "RepoState"
                                                                                                                "Runtime.Types"
                                                                                                                "main"
                                                                                                                'GHC.Types.False>_P
                                                                                                             <GHC.Generics.M1
                                                                                                                GHC.Generics.C
                                                                                                                ('GHC.Generics.MetaCons
                                                                                                                   "RepoState"
                                                                                                                   'GHC.Generics.PrefixI
                                                                                                                   'GHC.Types.True)
                                                                                                                (GHC.Generics.S1
                                                                                                                   ('GHC.Generics.MetaSel
                                                                                                                      ('GHC.Maybe.Just
                                                                                                                         "branches")
                                                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                                                      'GHC.Generics.NoSourceStrictness
                                                                                                                      'GHC.Generics.DecidedLazy)
                                                                                                                   (GHC.Generics.Rec0
                                                                                                                      (Data.Map.Internal.Map
                                                                                                                         HGit.Core.Types.BranchName
                                                                                                                         (HGit.Core.Types.Hash
                                                                                                                            HGit.Core.Types.HashableCommit)))
                                                                                                                 GHC.Generics.:*: GHC.Generics.S1
                                                                                                                                    ('GHC.Generics.MetaSel
                                                                                                                                       ('GHC.Maybe.Just
                                                                                                                                          "currentBranch")
                                                                                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                                                                                       'GHC.Generics.NoSourceStrictness
                                                                                                                                       'GHC.Generics.DecidedLazy)
                                                                                                                                    (GHC.Generics.Rec0
                                                                                                                                       HGit.Core.Types.BranchName))>_R)) <GHC.Types.Any>_N
                                 ->_R Sym (Data.ByteString.Builder.Internal.N:Builder[0]) ; Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                                                                     <Data.Aeson.Types.Internal.Value>_P)) ; Nth:3
                                                                                                                                                 (Nth:3
                                                                                                                                                      (<Data.Aeson.Types.Internal.Options>_R
                                                                                                                                                       ->_R <Data.Aeson.Types.ToJSON.ToArgs
                                                                                                                                                               Data.Aeson.Encoding.Internal.Encoding
                                                                                                                                                               Data.Aeson.Types.Generic.Zero
                                                                                                                                                               GHC.Types.Any>_R
                                                                                                                                                       ->_R Sub (Sym (Runtime.Types.Rep_RepoState[0])) <GHC.Types.Any>_N
                                                                                                                                                       ->_R <Data.Aeson.Encoding.Internal.Encoding>_R))) ; Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                                                                                                                                                                               <Data.Aeson.Types.Internal.Value>_P))
                       eta1
                 } in
                 System.IO.withBinaryFile1
                   @ ()
                   (Runtime.Capabilities.hgitState'1 ipv3)
                   GHC.IO.IOMode.WriteMode
                   lvl40
                     `cast`
                   (<GHC.IO.Handle.Types.Handle>_R
                    ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                   ipv2 } }) -}
1168a4a123cfc15de3d5a87e99c87d4a
  $wmkBranch ::
    HGit.Core.Types.BranchName
    -> Data.Map.Internal.Map
         HGit.Core.Types.BranchName
         (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
    -> HGit.Core.Types.BranchName
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 4, Strictness: <L,U><S,U><S,U><S,U>, Inline: [2],
     Unfolding: (\ (w :: HGit.Core.Types.BranchName)
                   (ww :: Data.Map.Internal.Map
                            HGit.Core.Types.BranchName
                            (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit))
                   (ww1 :: HGit.Core.Types.BranchName)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Runtime.Capabilities.$slookup1
                        @ (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                        ww1
                        ww of wild1 {
                   GHC.Maybe.Nothing
                   -> case Runtime.RunCmd.mkBranch2 w2 ww1
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Maybe.Maybe Runtime.Types.RepoState #)
                      of {}
                   GHC.Maybe.Just x1
                   -> (# w2,
                         GHC.Maybe.Just
                           @ Runtime.Types.RepoState
                           (Runtime.Types.RepoState
                              (Runtime.RunCmd.$sinsert_$sgo13
                                 @ (Data.Functor.Const.Const
                                      Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                                 w
                                 w
                                 x1
                                 ww)
                              w) #) }) -}
e1a54b2b46748ba505287da175aebc1e
  $wmkCommit ::
    GHC.Base.String
    -> Runtime.Capabilities.HgitStore GHC.Types.IO
    -> Data.Map.Internal.Map
         HGit.Core.Types.BranchName
         (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
    -> HGit.Core.Types.BranchName
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 6,
     Strictness: <L,U><L,U(U(U,U(U)),U(U,U(U)),U(U,U(U)))><S,U><S,U><L,U><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Base.String)
                   (ww :: Runtime.Capabilities.HgitStore GHC.Types.IO)
                   (ww1 :: Data.Map.Internal.Map
                             HGit.Core.Types.BranchName
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit))
                   (ww2 :: HGit.Core.Types.BranchName)
                   (ww3 :: GHC.IO.FilePath)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Runtime.Capabilities.$slookup1
                        @ (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                        ww2
                        ww1 of wild1 {
                   GHC.Maybe.Nothing
                   -> case Runtime.RunCmd.mkBranch2 w2 ww2
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                GHC.Maybe.Maybe Runtime.Types.RepoState #)
                      of {}
                   GHC.Maybe.Just x1
                   -> case (Runtime.FileIO.readTree ww3)
                             `cast`
                           (GHC.Types.N:IO[0]
                                <Data.Functor.Foldable.Fix
                                   (HGit.Core.Types.Dir
                                      (Data.Functor.Foldable.Fix HGit.Core.Types.Blob))>_R)
                             w2 of ds1 { (#,#) ipv ipv1 ->
                      let {
                        ds2 :: Runtime.Types.RepoState = Runtime.Types.RepoState ww1 ww2
                      } in
                      let {
                        wild :: Runtime.Capabilities.RepoCaps GHC.Types.IO
                        = Runtime.Capabilities.RepoCaps @ GHC.Types.IO ww ds2 ww3
                      } in
                      case ((Util.RecursionSchemes.bitraverseFix
                               @ HGit.Core.Types.Dir
                               @ (Control.Monad.Trans.Reader.ReaderT
                                    (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                               @ (Data.Functor.Foldable.Fix HGit.Core.Types.Blob)
                               @ (Merkle.Types.Hash
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                               HGit.Core.Types.$fBitraversableDir
                               (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                                  @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                               (HGit.Core.Types.$fTraversableDir
                                  @ (Data.Functor.Foldable.Fix HGit.Core.Types.Blob))
                               (Util.RecursionSchemes.cataM
                                  @ (Control.Monad.Trans.Reader.ReaderT
                                       (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                                  @ HGit.Core.Types.Blob
                                  @ (Merkle.Types.Hash
                                       Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                  (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                                     @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                                  HGit.Core.Types.$fTraversableBlob
                                  (case ww of wild2 { Runtime.Capabilities.HgitStore ds4 ds5 ds3 ->
                                   case ds4 of wild3 { (,) g p ->
                                   case p of wild4 { Merkle.Store.PutCapability g1 ->
                                   \ (x :: HGit.Core.Types.Blob
                                             (Merkle.Types.Hash
                                                Merkle.Types.IPFS.RawIPFSHash
                                                HGit.Core.Types.Blob)) ->
                                   let {
                                     m1 :: GHC.Types.IO
                                             (Merkle.Types.Hash
                                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                     = g1 x
                                   } in
                                   (\ (ds :: Runtime.Capabilities.RepoCaps GHC.Types.IO) -> m1)
                                     `cast`
                                   (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                             <Type>_N
                                             <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                                             <GHC.Types.IO>_R
                                             <Merkle.Types.Hash
                                                Merkle.Types.IPFS.RawIPFSHash
                                                HGit.Core.Types.Blob>_N)) } } }))
                               ipv1)
                              `cast`
                            (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <Type>_N
                                 <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                                 <GHC.Types.IO>_R
                                 <Data.Functor.Foldable.Fix
                                    (HGit.Core.Types.Dir
                                       (Merkle.Types.Hash
                                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))>_N)
                              wild)
                             `cast`
                           (GHC.Types.N:IO[0]
                                <Data.Functor.Foldable.Fix
                                   (HGit.Core.Types.Dir
                                      (Merkle.Types.Hash
                                         Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))>_R)
                             ipv of ds4 { (#,#) ipv2 ipv3 ->
                      case ((Util.RecursionSchemes.cataM
                               @ (Control.Monad.Trans.Reader.ReaderT
                                    (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                               @ HGit.Core.Types.HashableDir
                               @ (Merkle.Types.Hash
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                               (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                                  @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                               (HGit.Core.Types.$fTraversableDir
                                  @ (Data.Functor.Const.Const
                                       Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                               (case ww of wild2 { Runtime.Capabilities.HgitStore ds5 ds6 ds3 ->
                                case ds6 of wild3 { (,) g p ->
                                case p of wild4 { Merkle.Store.PutCapability g1 ->
                                \ (x :: HGit.Core.Types.HashableDir
                                          (Merkle.Types.Hash
                                             Merkle.Types.IPFS.RawIPFSHash
                                             HGit.Core.Types.HashableDir)) ->
                                let {
                                  m1 :: GHC.Types.IO
                                          (Merkle.Types.Hash
                                             Merkle.Types.IPFS.RawIPFSHash
                                             HGit.Core.Types.HashableDir)
                                  = g1 x
                                } in
                                (\ (ds :: Runtime.Capabilities.RepoCaps GHC.Types.IO) -> m1)
                                  `cast`
                                (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                          <Type>_N
                                          <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                                          <GHC.Types.IO>_R
                                          <Merkle.Types.Hash
                                             Merkle.Types.IPFS.RawIPFSHash
                                             HGit.Core.Types.HashableDir>_N)) } } })
                               ipv3)
                              `cast`
                            (Control.Monad.Trans.Reader.N:ReaderT[0]
                                 <Type>_N
                                 <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                                 <GHC.Types.IO>_R
                                 <Merkle.Types.Hash
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir>_N)
                              wild)
                             `cast`
                           (GHC.Types.N:IO[0]
                                <Merkle.Types.Hash
                                   Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir>_R)
                             ipv2 of ds5 { (#,#) ipv4 ipv5 ->
                      case ww of wild2 { Runtime.Capabilities.HgitStore ds6 ds7 ds3 ->
                      case ds3 of wild3 { (,) g p ->
                      case p of wild4 { Merkle.Store.PutCapability g1 ->
                      case (g1
                              (HGit.Core.Types.Commit
                                 @ (Merkle.Types.Hash
                                      Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                                 @ (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
                                 w
                                 ipv5
                                 (GHC.Base.$fApplicativeNonEmpty_$cpure
                                    @ (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
                                    x1)))
                             `cast`
                           (GHC.Types.N:IO[0]
                                <HGit.Core.Types.Hash HGit.Core.Types.HashableCommit>_R)
                             ipv4 of ds8 { (#,#) ipv6 ipv7 ->
                      (# ipv6,
                         GHC.Maybe.Just
                           @ Runtime.Types.RepoState
                           (Runtime.Types.RepoState
                              (Runtime.RunCmd.$sinsert_$sgo13
                                 @ (Data.Functor.Const.Const
                                      Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                                 ww2
                                 ww2
                                 ipv7
                                 ww1)
                              ww2) #) } } } } } } } }) -}
12e9a84849439384a648155826654c66
  $wmkMergeCommit ::
    HGit.Core.Types.BranchName
    -> GHC.Base.String
    -> HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.Blob
    -> HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.HashableDir
    -> (Merkle.Types.Hash
          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit
        -> GHC.Types.IO
             (GHC.Maybe.Maybe
                (Merkle.Store.DerefRes
                   Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)))
    -> Merkle.Store.PutCapability
         GHC.Types.IO
         Merkle.Types.IPFS.RawIPFSHash
         HGit.Core.Types.HashableCommit
    -> Data.Map.Internal.Map
         HGit.Core.Types.BranchName
         (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
    -> HGit.Core.Types.BranchName
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 10,
     Strictness: <L,U><L,U><L,U(U(U),U(U))><L,U(U(U),U(U))><C(C(S(SS))),U><L,U(U)><S,U><S,U><L,U><S,U>,
     Inline: [2] -}
ca6bf6d68a9a0536efb33d45a8a45ba3
  $wprintDiff ::
    (forall a. GHC.Types.IO a -> m a)
    -> [GHC.IO.FilePath] -> HGit.Core.Diff.Diff -> m ()
  {- Arity: 3, Strictness: <C(S),1*C1(U)><L,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ @ m :: Type -> Type
                   (ww :: forall a. GHC.Types.IO a -> m a)
                   (ww1 :: [GHC.IO.FilePath])
                   (ww2 :: HGit.Core.Diff.Diff) ->
                 ww
                   @ ()
                   (GHC.IO.Handle.Text.hPutStr'
                      GHC.IO.Handle.FD.stdout
                      (GHC.CString.unpackAppendCString#
                         Runtime.RunCmd.printDiff5
                         (let {
                            n :: [GHC.Types.Char]
                            = GHC.CString.unpackAppendCString#
                                Runtime.RunCmd.printDiff4
                                (case ww1 of wild {
                                   [] -> GHC.Types.[] @ GHC.Types.Char
                                   : x xs1
                                   -> Data.OldList.intercalate_$spoly_go
                                        @ GHC.Types.Char
                                        x
                                        (Data.OldList.prependToAll
                                           @ [GHC.Types.Char]
                                           Runtime.RunCmd.printDiff2
                                           xs1) })
                          } in
                          case ww2 of wild {
                            HGit.Core.Diff.FileModified
                            -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff9 n
                            HGit.Core.Diff.FileReplacedWithDir
                            -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff7 n
                            HGit.Core.Diff.DirReplacedWithFile
                            -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff5 n
                            HGit.Core.Diff.EntityDeleted
                            -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff3 n
                            HGit.Core.Diff.EntityCreated
                            -> GHC.Base.++ @ GHC.Types.Char HGit.Core.Diff.$fShowDiff1 n }))
                      GHC.Types.True)) -}
3381b8bc38cbf6d36ac6c75f23c8fd17
  $wrunCommand ::
    Runtime.Commands.RepoCommand
    -> Runtime.Capabilities.HgitStore GHC.Types.IO
    -> Data.Map.Internal.Map
         HGit.Core.Types.BranchName
         (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
    -> HGit.Core.Types.BranchName
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 6,
     Strictness: <S,1*U><L,U(U(U(U),U(U)),U(U(U),U(U)),U(U(U),U(U)))><S,U><L,U><L,U><S,U>,
     Inline: [2] -}
5e418e1f29119dc0d204773e834c2494
  $wsetDirTo ::
    [HGit.Core.Types.NamedFileTreeEntity x y]
    -> HGit.Core.Types.Hash HGit.Core.Types.HashableDir
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4,
     Strictness: <S,1*U><L,U><L,U(U(U(U(U),U),U(U(U),U),U),U,U)><S,U>,
     Inline: [2],
     Unfolding: (\ @ x
                   @ y
                   (ww :: [HGit.Core.Types.NamedFileTreeEntity x y])
                   (w :: HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                   (w2 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Runtime.RunCmd.setDirTo5
                        @ y
                        @ x
                        ww
                        w3 of ds1 { (#,#) ipv ipv1 ->
                 case ((Runtime.RunCmd.setDirTo4
                          (Merkle.Store.Deref.lazyDeref'
                             @ (Control.Monad.Trans.Reader.ReaderT
                                  (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                             @ Merkle.Types.IPFS.RawIPFSHash
                             @ HGit.Core.Types.HashableDir
                             (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                                @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                             (Runtime.RunCmd.$s$fMonadThrowReaderT
                                @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                             (HGit.Core.Types.$fFunctorDir
                                @ (Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                             Merkle.Types.IPFS.$fShowRawIPFSHash
                             (case w2 of wild { Runtime.Capabilities.RepoCaps ds2 ds3 ds4 ->
                              case ds2 of wild1 { Runtime.Capabilities.HgitStore ds5 ds6 ds7 ->
                              case ds6 of wild2 { (,) g p ->
                              case g of wild3 { Merkle.Store.GetCapability g1 ->
                              Merkle.Store.GetCapability
                                @ (Control.Monad.Trans.Reader.ReaderT
                                     (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                                @ Merkle.Types.IPFS.RawIPFSHash
                                @ HGit.Core.Types.HashableDir
                                (\ (x1 :: Merkle.Types.Hash
                                            Merkle.Types.IPFS.RawIPFSHash
                                            HGit.Core.Types.HashableDir) ->
                                 let {
                                   m1 :: GHC.Types.IO
                                           (GHC.Maybe.Maybe
                                              (Merkle.Store.DerefRes
                                                 Merkle.Types.IPFS.RawIPFSHash
                                                 HGit.Core.Types.HashableDir))
                                   = g1 x1
                                 } in
                                 (\ (ds :: Runtime.Capabilities.RepoCaps GHC.Types.IO) -> m1)
                                   `cast`
                                 (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                           <Type>_N
                                           <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                                           <GHC.Types.IO>_R
                                           <GHC.Maybe.Maybe
                                              (Merkle.Store.DerefRes
                                                 Merkle.Types.IPFS.RawIPFSHash
                                                 HGit.Core.Types.HashableDir)>_N))) } } } })
                             w))
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N
                            <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                            <GHC.Types.IO>_R
                            <Data.Functor.Foldable.Fix
                               (Data.Functor.Compose.Compose
                                  (Merkle.Functors.HashAnnotated
                                     Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                                  HGit.Core.Types.HashableDir)>_N)
                         w2)
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Data.Functor.Foldable.Fix
                              (Data.Functor.Compose.Compose
                                 (Merkle.Functors.HashAnnotated
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                                 HGit.Core.Types.HashableDir)>_R)
                        ipv of ds { (#,#) ipv2 ipv3 ->
                 case ((Util.RecursionSchemes.bitraverseFix
                          @ HGit.Core.Types.Dir
                          @ (Control.Monad.Trans.Reader.ReaderT
                               (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                          @ (Merkle.Types.Hash
                               Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                          @ (Data.Functor.Foldable.Fix HGit.Core.Types.Blob)
                          HGit.Core.Types.$fBitraversableDir
                          (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                             @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                          (HGit.Core.Types.$fTraversableDir
                             @ (Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                          (let {
                             g :: Merkle.Types.Hash
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob
                                  -> Data.Functor.Foldable.Fix
                                       (Data.Functor.Compose.Compose
                                          (Merkle.Functors.HashAnnotated
                                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                          (Data.Functor.Compose.Compose
                                             (Control.Monad.Trans.Reader.ReaderT
                                                (Runtime.Capabilities.RepoCaps GHC.Types.IO)
                                                GHC.Types.IO)
                                             HGit.Core.Types.Blob))
                             = Merkle.Store.Deref.lazyDeref'
                                 @ (Control.Monad.Trans.Reader.ReaderT
                                      (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                                 @ Merkle.Types.IPFS.RawIPFSHash
                                 @ HGit.Core.Types.Blob
                                 (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                                    @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                                 (Runtime.RunCmd.$s$fMonadThrowReaderT
                                    @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))
                                 HGit.Core.Types.$fFunctorBlob
                                 Merkle.Types.IPFS.$fShowRawIPFSHash
                                 (case w2 of wild { Runtime.Capabilities.RepoCaps ds2 ds3 ds4 ->
                                  case ds2 of wild1 { Runtime.Capabilities.HgitStore ds5 ds6 ds7 ->
                                  case ds5 of wild2 { (,) g1 p ->
                                  case g1 of wild3 { Merkle.Store.GetCapability g2 ->
                                  Merkle.Store.GetCapability
                                    @ (Control.Monad.Trans.Reader.ReaderT
                                         (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                                    @ Merkle.Types.IPFS.RawIPFSHash
                                    @ HGit.Core.Types.Blob
                                    (\ (x1 :: Merkle.Types.Hash
                                                Merkle.Types.IPFS.RawIPFSHash
                                                HGit.Core.Types.Blob) ->
                                     let {
                                       m1 :: GHC.Types.IO
                                               (GHC.Maybe.Maybe
                                                  (Merkle.Store.DerefRes
                                                     Merkle.Types.IPFS.RawIPFSHash
                                                     HGit.Core.Types.Blob))
                                       = g2 x1
                                     } in
                                     (\ (ds8 :: Runtime.Capabilities.RepoCaps GHC.Types.IO) -> m1)
                                       `cast`
                                     (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                               <Type>_N
                                               <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                                               <GHC.Types.IO>_R
                                               <GHC.Maybe.Maybe
                                                  (Merkle.Store.DerefRes
                                                     Merkle.Types.IPFS.RawIPFSHash
                                                     HGit.Core.Types.Blob)>_N))) } } } })
                           } in
                           \ (x1 :: Merkle.Types.Hash
                                      Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob) ->
                           let {
                             m1 :: Control.Monad.Trans.Reader.ReaderT
                                     (Runtime.Capabilities.RepoCaps GHC.Types.IO)
                                     GHC.Types.IO
                                     (Data.Functor.Foldable.Fix
                                        (Data.Functor.Compose.Compose
                                           (Merkle.Functors.HashAnnotated
                                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                           HGit.Core.Types.Blob))
                             = Runtime.RunCmd.setDirTo_f (g x1)
                           } in
                           (\ (x2 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                              (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case (m1
                                    `cast`
                                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                                       <Type>_N
                                       <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                                       <GHC.Types.IO>_R
                                       <Data.Functor.Foldable.Fix
                                          (Data.Functor.Compose.Compose
                                             (Merkle.Functors.HashAnnotated
                                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                             HGit.Core.Types.Blob)>_N)
                                    x2)
                                   `cast`
                                 (GHC.Types.N:IO[0]
                                      <Data.Functor.Foldable.Fix
                                         (Data.Functor.Compose.Compose
                                            (Merkle.Functors.HashAnnotated
                                               Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                            HGit.Core.Types.Blob)>_R)
                                   s of ds2 { (#,#) ipv4 ipv5 ->
                            (# ipv4,
                               (Runtime.RunCmd.setDirTo_c1 ipv5)
                                 `cast`
                               (Sym (Data.Functor.Foldable.N:Fix[0]
                                         <HGit.Core.Types.Blob>_N)) #) })
                             `cast`
                           ((<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                             ->_R Sym (GHC.Types.N:IO[0]
                                           <Data.Functor.Foldable.Fix
                                              HGit.Core.Types.Blob>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                   <Type>_N
                                                                                   <Runtime.Capabilities.RepoCaps
                                                                                      GHC.Types.IO>_R
                                                                                   <GHC.Types.IO>_R
                                                                                   <Data.Functor.Foldable.Fix
                                                                                      HGit.Core.Types.Blob>_N)))
                          (Runtime.RunCmd.setDirTo_c ipv3)
                            `cast`
                          (Sym (Data.Functor.Foldable.N:Fix[0]
                                    <HGit.Core.Types.HashableDir>_N)))
                         `cast`
                       (Control.Monad.Trans.Reader.N:ReaderT[0]
                            <Type>_N
                            <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                            <GHC.Types.IO>_R
                            <Data.Functor.Foldable.Fix
                               (HGit.Core.Types.Dir
                                  (Data.Functor.Foldable.Fix HGit.Core.Types.Blob))>_N)
                         w2)
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Data.Functor.Foldable.Fix
                              (HGit.Core.Types.Dir
                                 (Data.Functor.Foldable.Fix HGit.Core.Types.Blob))>_R)
                        ipv2 of ds2 { (#,#) ipv4 ipv5 ->
                 ((Runtime.RunCmd.setDirTo2
                     (case w2 of wild { Runtime.Capabilities.RepoCaps ds3 ds4 ds5 ->
                      ds5 })
                     ipv5)
                    `cast`
                  (Control.Monad.Trans.Reader.N:ReaderT[0]
                       <Type>_N
                       <Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       <GHC.Types.IO>_R
                       <()>_N)
                    w2)
                   `cast`
                 (GHC.Types.N:IO[0] <()>_R)
                   ipv4 } } }) -}
f7d414d0550d7ecfb047a849d7ba97b6
  $wstatus ::
    HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.Blob
    -> HGit.Core.Types.Store GHC.Types.IO HGit.Core.Types.HashableDir
    -> (Merkle.Types.Hash
          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit
        -> GHC.Types.IO
             (GHC.Maybe.Maybe
                (Merkle.Store.DerefRes
                   Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)))
    -> Merkle.Store.PutCapability
         GHC.Types.IO
         Merkle.Types.IPFS.RawIPFSHash
         HGit.Core.Types.HashableCommit
    -> Data.Map.Internal.Map
         HGit.Core.Types.BranchName
         (HGit.Core.Types.Hash HGit.Core.Types.HashableCommit)
    -> HGit.Core.Types.BranchName
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [([HGit.Core.Types.PartialFilePath], HGit.Core.Diff.Diff)] #)
  {- Arity: 8,
     Strictness: <L,U(U,U(U))><L,U(U(U),U(U))><C(C(S(SS))),U><L,U><S,U><S,U><L,U><S,U>,
     Inline: [2] -}
4db8a21974a1af38b64271d76a5baaf0
  checkoutBranch ::
    HGit.Core.Types.BranchName
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (GHC.Maybe.Maybe Runtime.Types.RepoState)
  {- Arity: 3,
     Strictness: <S,U><S(S(LLS(S(C(C(S(SS))))L))S(SL)L),1*U(1*U(U(U(U),U(U)),U(U(U),U(U)),1*U(1*U(U),U)),1*U(U,U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.checkoutBranch1
                  `cast`
                (<HGit.Core.Types.BranchName>_R
                 ->_R (<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <GHC.Maybe.Maybe
                                        Runtime.Types.RepoState>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                <Type>_N
                                                                                <Runtime.Capabilities.RepoCaps
                                                                                   GHC.Types.IO>_R
                                                                                <GHC.Types.IO>_R
                                                                                <GHC.Maybe.Maybe
                                                                                   Runtime.Types.RepoState>_N)) -}
04345e3c62aa22deee08380ccaeee5d1
  checkoutBranch1 ::
    HGit.Core.Types.BranchName
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 3,
     Strictness: <S,U><S(S(LLS(S(C(C(S(SS))))L))S(SL)L),1*U(1*U(U(U(U),U(U)),U(U(U),U(U)),1*U(1*U(U),U)),1*U(U,U),U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: HGit.Core.Types.BranchName)
                   (w2 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w2 of ww { Runtime.Capabilities.RepoCaps ww1 ww2 ww3 ->
                 case ww1 of ww4 { Runtime.Capabilities.HgitStore ww5 ww6 ww7 ->
                 case ww7 of ww8 { (,) ww9 ww10 ->
                 case ww9 of ww11 { Merkle.Store.GetCapability ww12 ->
                 case ww2 of ww13 { Runtime.Types.RepoState ww14 ww15 ->
                 Runtime.RunCmd.$wcheckoutBranch
                   w
                   ww5
                   ww6
                   ww12
                   ww10
                   ww14
                   ww15
                   ww3
                   w3 } } } } }) -}
722c309735938acfb194fdabd2edd4ea
  commitRoot ::
    GHC.Base.Monad m =>
    HGit.Core.Types.HashableCommit x
    -> m (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
  {- Arity: 2,
     Strictness: <S,1*U(1*U(A,1*C1(U),A,A,A,A),A,A,A,1*C1(U))><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: Type -> Type
                   @ x
                   (w :: GHC.Base.Monad m)
                   (w2 :: HGit.Core.Types.HashableCommit x) ->
                 case w of ww { GHC.Base.C:Monad ww1 ww2 ww3 ww4 ww5 ->
                 Runtime.RunCmd.$wcommitRoot @ m @ x ww1 ww5 w2 }) -}
16df999e44559c359f34260dedf8b31b
  commitRoot2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Runtime.RunCmd.commitRoot3) -}
2a3fc51677090ffb83873965bbe6c9c7
  commitRoot3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("can't get commit root dir for Null Commit"#) -}
c98fa3dd82f3ea2524c30fd63dc2e581
  commitRoot_m1 ::
    GHC.Types.IO (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
  {- Unfolding: (GHC.Magic.noinline
                   @ (forall a. [GHC.Types.Char] -> GHC.Types.IO a)
                   GHC.IO.failIO1
                     `cast`
                   (forall (a :: <Type>_N).
                    <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R))
                   @ (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                   Runtime.RunCmd.commitRoot2) -}
b01c2782231e7ff96ebb9dfb38338f45
  getDiff ::
    HGit.Core.Types.BranchName
    -> HGit.Core.Types.BranchName
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (GHC.Maybe.Maybe Runtime.Types.RepoState)
  {- Arity: 4,
     Strictness: <S,U><L,U><S(S(LLS(S(C(C(S(SS))))L))S(SL)L),1*U(1*U(U,U(U(U),U),1*U(1*U(U),U)),1*U(U,U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.getDiff1
                  `cast`
                (<HGit.Core.Types.BranchName>_R
                 ->_R <HGit.Core.Types.BranchName>_R
                 ->_R (<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <GHC.Maybe.Maybe
                                        Runtime.Types.RepoState>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                <Type>_N
                                                                                <Runtime.Capabilities.RepoCaps
                                                                                   GHC.Types.IO>_R
                                                                                <GHC.Types.IO>_R
                                                                                <GHC.Maybe.Maybe
                                                                                   Runtime.Types.RepoState>_N)) -}
820df8b356043cde3fa9b2bbda576bd3
  getDiff1 ::
    HGit.Core.Types.BranchName
    -> HGit.Core.Types.BranchName
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 4,
     Strictness: <S,U><L,U><S(S(LLS(S(C(C(S(SS))))L))S(SL)L),1*U(1*U(U,U(U(U),U),1*U(1*U(U),U)),1*U(U,U),U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: HGit.Core.Types.BranchName)
                   (w2 :: HGit.Core.Types.BranchName)
                   (w3 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w4 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w3 of ww { Runtime.Capabilities.RepoCaps ww1 ww2 ww3 ->
                 case ww1 of ww4 { Runtime.Capabilities.HgitStore ww5 ww6 ww7 ->
                 case ww7 of ww8 { (,) ww9 ww10 ->
                 case ww9 of ww11 { Merkle.Store.GetCapability ww12 ->
                 case ww2 of ww13 { Runtime.Types.RepoState ww14 ww15 ->
                 Runtime.RunCmd.$wgetDiff
                   w
                   w2
                   ww5
                   ww6
                   ww12
                   ww10
                   ww14
                   ww15
                   ww3
                   w4 } } } } }) -}
2f74630620d08385904ec164af7f5ed3
  initRepo :: Merkle.Store.IPFS.IPFSNode -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U(U))><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.initRepo1
                  `cast`
                (<Merkle.Store.IPFS.IPFSNode>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
9f49857cd0e7d6bfd96669d03c09dedb
  initRepo1 ::
    Merkle.Store.IPFS.IPFSNode
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U(U))><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Merkle.Store.IPFS.IPFSNode)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { Merkle.Store.IPFS.IPFSNode ww1 ww2 ->
                 Runtime.RunCmd.$winitRepo ww1 ww2 w2 }) -}
87070bb1620a8d9794b7df2214a80f30
  mkBranch ::
    HGit.Core.Types.BranchName
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (GHC.Maybe.Maybe Runtime.Types.RepoState)
  {- Arity: 3, Strictness: <L,U><S(LS(SS)L),1*U(A,1*U(U,U),A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.mkBranch1
                  `cast`
                (<HGit.Core.Types.BranchName>_R
                 ->_R (<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <GHC.Maybe.Maybe
                                        Runtime.Types.RepoState>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                <Type>_N
                                                                                <Runtime.Capabilities.RepoCaps
                                                                                   GHC.Types.IO>_R
                                                                                <GHC.Types.IO>_R
                                                                                <GHC.Maybe.Maybe
                                                                                   Runtime.Types.RepoState>_N)) -}
d9a0dba896a230af3c55c3f9fc8b1254
  mkBranch1 ::
    HGit.Core.Types.BranchName
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 3, Strictness: <L,U><S(LS(SS)L),1*U(A,1*U(U,U),A)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: HGit.Core.Types.BranchName)
                   (w2 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w2 of ww { Runtime.Capabilities.RepoCaps ww1 ww2 ww3 ->
                 case ww2 of ww4 { Runtime.Types.RepoState ww5 ww6 ->
                 Runtime.RunCmd.$wmkBranch w ww5 ww6 w3 } }) -}
07f51491a4d2c9f524398fd240977816
  mkBranch2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> HGit.Core.Types.BranchName
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          HGit.Core.Types.Hash HGit.Core.Types.HashableCommit #)
  {- Arity: 2, Strictness: <B,U><B,U>x -}
0a83694b4da99b4b4b7fba3c1e1a793c
  mkCommit ::
    GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (GHC.Maybe.Maybe Runtime.Types.RepoState)
  {- Arity: 3,
     Strictness: <L,U><S(LS(SS)L),1*U(U(U(U,U(U)),U(U,U(U)),U(U,U(U))),1*U(U,U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.mkCommit1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R (<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <GHC.Maybe.Maybe
                                        Runtime.Types.RepoState>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                <Type>_N
                                                                                <Runtime.Capabilities.RepoCaps
                                                                                   GHC.Types.IO>_R
                                                                                <GHC.Types.IO>_R
                                                                                <GHC.Maybe.Maybe
                                                                                   Runtime.Types.RepoState>_N)) -}
76bad378d096c170043903c36ed599e0
  mkCommit1 ::
    GHC.Base.String
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 3,
     Strictness: <L,U><S(LS(SS)L),1*U(U(U(U,U(U)),U(U,U(U)),U(U,U(U))),1*U(U,U),U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String)
                   (w2 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w2 of ww { Runtime.Capabilities.RepoCaps ww1 ww2 ww3 ->
                 case ww2 of ww4 { Runtime.Types.RepoState ww5 ww6 ->
                 Runtime.RunCmd.$wmkCommit w ww1 ww5 ww6 ww3 w3 } }) -}
3ae7c0169841f702d4dbb276f5a05f60
  mkMergeCommit ::
    HGit.Core.Types.BranchName
    -> GHC.Base.String
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (GHC.Maybe.Maybe Runtime.Types.RepoState)
  {- Arity: 4,
     Strictness: <L,U><L,U><S(S(LLS(S(C(C(S(SS))))L))S(SS)L),1*U(1*U(U(U(U),U(U)),U(U(U),U(U)),1*U(1*U(U),U(U))),1*U(U,U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.mkMergeCommit1
                  `cast`
                (<HGit.Core.Types.BranchName>_R
                 ->_R <GHC.Base.String>_R
                 ->_R (<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <GHC.Maybe.Maybe
                                        Runtime.Types.RepoState>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                <Type>_N
                                                                                <Runtime.Capabilities.RepoCaps
                                                                                   GHC.Types.IO>_R
                                                                                <GHC.Types.IO>_R
                                                                                <GHC.Maybe.Maybe
                                                                                   Runtime.Types.RepoState>_N)) -}
6cbe1b28e31f712943cde7a223f393e1
  mkMergeCommit1 ::
    HGit.Core.Types.BranchName
    -> GHC.Base.String
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 4,
     Strictness: <L,U><L,U><S(S(LLS(S(C(C(S(SS))))L))S(SS)L),1*U(1*U(U(U(U),U(U)),U(U(U),U(U)),1*U(1*U(U),U(U))),1*U(U,U),U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: HGit.Core.Types.BranchName)
                   (w2 :: GHC.Base.String)
                   (w3 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w4 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w3 of ww { Runtime.Capabilities.RepoCaps ww1 ww2 ww3 ->
                 case ww1 of ww4 { Runtime.Capabilities.HgitStore ww5 ww6 ww7 ->
                 case ww7 of ww8 { (,) ww9 ww10 ->
                 case ww9 of ww11 { Merkle.Store.GetCapability ww12 ->
                 case ww2 of ww13 { Runtime.Types.RepoState ww14 ww15 ->
                 Runtime.RunCmd.$wmkMergeCommit
                   w
                   w2
                   ww5
                   ww6
                   ww12
                   ww10
                   ww14
                   ww15
                   ww3
                   w4 } } } } }) -}
fba3cd74fb9de7014c7e7d0a8808d9ab
  printDiff ::
    Control.Monad.IO.Class.MonadIO m =>
    ([GHC.IO.FilePath], HGit.Core.Diff.Diff) -> m ()
  {- Arity: 2, Strictness: <S(LC(S)),1*U(A,1*C1(U))><S,1*U(1*U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ m :: Type -> Type
                   (w :: Control.Monad.IO.Class.MonadIO m)
                   (w2 :: ([GHC.IO.FilePath], HGit.Core.Diff.Diff)) ->
                 case w of ww { Control.Monad.IO.Class.C:MonadIO ww1 ww2 ->
                 case w2 of ww3 { (,) ww4 ww5 ->
                 Runtime.RunCmd.$wprintDiff @ m ww2 ww4 ww5 } }) -}
ba48a465a6307f28a1bfe698ecf3d87a
  printDiff2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Runtime.RunCmd.printDiff3) -}
a3d9d41283d1b89b66c5b3742b103f18
  printDiff3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/"#) -}
85fe43c3fca6e5c19b90b9b1694e504c
  printDiff4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" at "#) -}
5fd2cb18a3d9e0369175c43a81d1dba6
  printDiff5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\t"#) -}
1b6adc2f9be8a74a23a9601f1ca8ae3d
  runCommand ::
    Runtime.Commands.RepoCommand
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (GHC.Maybe.Maybe Runtime.Types.RepoState)
  {- Arity: 3,
     Strictness: <S,1*U><S(LS(SL)L),1*U(U(U(U(U),U(U)),U(U(U),U(U)),U(U(U),U(U))),1*U(U,U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.runCommand1
                  `cast`
                (<Runtime.Commands.RepoCommand>_R
                 ->_R (<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <GHC.Maybe.Maybe
                                        Runtime.Types.RepoState>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                                <Type>_N
                                                                                <Runtime.Capabilities.RepoCaps
                                                                                   GHC.Types.IO>_R
                                                                                <GHC.Types.IO>_R
                                                                                <GHC.Maybe.Maybe
                                                                                   Runtime.Types.RepoState>_N)) -}
9263eb777b2084b60f19877ac63af269
  runCommand1 ::
    Runtime.Commands.RepoCommand
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Maybe.Maybe Runtime.Types.RepoState #)
  {- Arity: 3,
     Strictness: <S,1*U><S(LS(SL)L),1*U(U(U(U(U),U(U)),U(U(U),U(U)),U(U(U),U(U))),1*U(U,U),U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Runtime.Commands.RepoCommand)
                   (w2 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w2 of ww { Runtime.Capabilities.RepoCaps ww1 ww2 ww3 ->
                 case ww2 of ww4 { Runtime.Types.RepoState ww5 ww6 ->
                 Runtime.RunCmd.$wrunCommand w ww1 ww5 ww6 ww3 w3 } }) -}
7c37653570577a9a553af6e9fa2c5057
  setDirTo ::
    HGit.Core.Types.Dir x y
    -> HGit.Core.Types.Hash HGit.Core.Types.HashableDir
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO ()
  {- Arity: 4,
     Strictness: <S(S),1*U(1*U)><L,U><L,U(U(U(U(U),U),U(U(U),U),U),U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.setDirTo1
                  `cast`
                (forall (x :: <Type>_N) (y :: <Type>_N).
                 <HGit.Core.Types.Dir x y>_R
                 ->_R <HGit.Core.Types.Hash HGit.Core.Types.HashableDir>_R
                 ->_R (<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <()>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                         <Type>_N
                                                         <Runtime.Capabilities.RepoCaps
                                                            GHC.Types.IO>_R
                                                         <GHC.Types.IO>_R
                                                         <()>_N)) -}
0d4e5ca9fe2b63caffbb88087d86243f
  setDirTo1 ::
    HGit.Core.Types.Dir x y
    -> HGit.Core.Types.Hash HGit.Core.Types.HashableDir
    -> Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4,
     Strictness: <S(S),1*U(1*U)><L,U><L,U(U(U(U(U),U),U(U(U),U),U),U,U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ @ x
                   @ y
                   (w :: HGit.Core.Types.Dir x y)
                   (w2 :: HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                   (w3 :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w4 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { HGit.Core.Types.Dir ww1 ->
                 Runtime.RunCmd.$wsetDirTo @ x @ y ww1 w2 w3 w4 }) -}
649881edde774765dc475bc96344a68c
  setDirTo2 ::
    GHC.IO.FilePath
    -> Data.Functor.Foldable.Fix
         (HGit.Core.Types.Dir
            (Data.Functor.Foldable.Fix HGit.Core.Types.Blob))
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO ()
  {- Unfolding: (Runtime.FileIO.writeTree
                   @ (Control.Monad.Trans.Reader.ReaderT
                        (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                   (Runtime.RunCmd.$s$fMonadIOReaderT
                      @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))) -}
691be819eb541fb2a9e7bcafc2586eed
  setDirTo3 ::
    (HGit.Core.Types.PartialFilePath,
     HGit.Core.Types.FileTreeEntity
       (Data.Functor.Const.Const
          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
       (Data.Functor.Foldable.Fix
          (Data.Functor.Compose.Compose
             (Merkle.Functors.HashAnnotated
                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
             HGit.Core.Types.HashableDir)))
    -> (HGit.Core.Types.PartialFilePath,
        HGit.Core.Types.FileTreeEntity
          (Data.Functor.Const.Const
             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
          (Data.Functor.Foldable.Fix HGit.Core.Types.HashableDir))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U)>m -}
b9ad15527a9ffde5878f0725d852784e
  setDirTo4 ::
    Data.Functor.Foldable.Fix
      (Data.Functor.Compose.Compose
         (Merkle.Functors.HashAnnotated
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
         (Data.Functor.Compose.Compose
            (Control.Monad.Trans.Reader.ReaderT
               (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
            HGit.Core.Types.HashableDir))
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (Data.Functor.Foldable.Fix
            (Data.Functor.Compose.Compose
               (Merkle.Functors.HashAnnotated
                  Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
               HGit.Core.Types.HashableDir))
  {- Unfolding: (Merkle.Store.Deref.strictDeref
                   @ HGit.Core.Types.HashableDir
                   @ (Control.Monad.Trans.Reader.ReaderT
                        (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                   @ Merkle.Types.IPFS.RawIPFSHash
                   (HGit.Core.Types.$fTraversableDir
                      @ (Data.Functor.Const.Const
                           Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                   (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                      @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))) -}
a11a4609e5ace957490e537f8d4ee3a9
  setDirTo5 ::
    [(GHC.IO.FilePath, HGit.Core.Types.FileTreeEntity x y)]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [()] #)
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
586986289630b80a701a7112cd366cde
  setDirTo_c ::
    Data.Functor.Foldable.Fix
      (Data.Functor.Compose.Compose
         (Merkle.Functors.HashAnnotated
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
         HGit.Core.Types.HashableDir)
    -> HGit.Core.Types.HashableDir
         (Data.Functor.Foldable.Fix HGit.Core.Types.HashableDir)
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(1*U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Functor.Foldable.Fix
                           (Data.Functor.Compose.Compose
                              (Merkle.Functors.HashAnnotated
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                              HGit.Core.Types.HashableDir)) ->
                 case w `cast`
                      (Data.Functor.Foldable.N:Fix[0]
                           <Data.Functor.Compose.Compose
                              (Merkle.Functors.HashAnnotated
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                              HGit.Core.Types.HashableDir>_N ; Data.Functor.Compose.N:Compose[0]
                                                                   <Type>_N
                                                                   <Type>_N
                                                                   <Merkle.Functors.HashAnnotated
                                                                      Merkle.Types.IPFS.RawIPFSHash
                                                                      HGit.Core.Types.HashableDir>_R
                                                                   <HGit.Core.Types.HashableDir>_N
                                                                   <Data.Functor.Foldable.Fix
                                                                      (Data.Functor.Compose.Compose
                                                                         (Merkle.Functors.HashAnnotated
                                                                            Merkle.Types.IPFS.RawIPFSHash
                                                                            HGit.Core.Types.HashableDir)
                                                                         HGit.Core.Types.HashableDir)>_N) of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { HGit.Core.Types.Dir ww4 ->
                 HGit.Core.Types.Dir
                   @ (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                   @ (Data.Functor.Foldable.Fix HGit.Core.Types.HashableDir)
                   (GHC.Base.build
                      @ (HGit.Core.Types.PartialFilePath,
                         HGit.Core.Types.FileTreeEntity
                           (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                           (Data.Functor.Foldable.Fix HGit.Core.Types.HashableDir))
                      (\ @ b1
                         (c :: (HGit.Core.Types.PartialFilePath,
                                HGit.Core.Types.FileTreeEntity
                                  (Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                  (Data.Functor.Foldable.Fix HGit.Core.Types.HashableDir))
                               -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (HGit.Core.Types.PartialFilePath,
                            HGit.Core.Types.FileTreeEntity
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                              (Data.Functor.Foldable.Fix
                                 (Data.Functor.Compose.Compose
                                    (Merkle.Functors.HashAnnotated
                                       Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                                    HGit.Core.Types.HashableDir)))
                         @ b1
                         (GHC.Base.mapFB
                            @ (HGit.Core.Types.PartialFilePath,
                               HGit.Core.Types.FileTreeEntity
                                 (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                 (Data.Functor.Foldable.Fix HGit.Core.Types.HashableDir))
                            @ b1
                            @ (HGit.Core.Types.PartialFilePath,
                               HGit.Core.Types.FileTreeEntity
                                 (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                 (Data.Functor.Foldable.Fix
                                    (Data.Functor.Compose.Compose
                                       (Merkle.Functors.HashAnnotated
                                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                                       HGit.Core.Types.HashableDir)))
                            c
                            Runtime.RunCmd.setDirTo3)
                         n
                         ww4)) } }) -}
41984046a746e3aa9afb4e8446549c1b
  setDirTo_c1 ::
    Data.Functor.Foldable.Fix
      (Data.Functor.Compose.Compose
         (Merkle.Functors.HashAnnotated
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
         HGit.Core.Types.Blob)
    -> HGit.Core.Types.Blob
         (Data.Functor.Foldable.Fix HGit.Core.Types.Blob)
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Functor.Foldable.Fix
                           (Data.Functor.Compose.Compose
                              (Merkle.Functors.HashAnnotated
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                              HGit.Core.Types.Blob)) ->
                 case w `cast`
                      (Data.Functor.Foldable.N:Fix[0]
                           <Data.Functor.Compose.Compose
                              (Merkle.Functors.HashAnnotated
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                              HGit.Core.Types.Blob>_N ; Data.Functor.Compose.N:Compose[0]
                                                            <Type>_N
                                                            <Type>_N
                                                            <Merkle.Functors.HashAnnotated
                                                               Merkle.Types.IPFS.RawIPFSHash
                                                               HGit.Core.Types.Blob>_R
                                                            <HGit.Core.Types.Blob>_N
                                                            <Data.Functor.Foldable.Fix
                                                               (Data.Functor.Compose.Compose
                                                                  (Merkle.Functors.HashAnnotated
                                                                     Merkle.Types.IPFS.RawIPFSHash
                                                                     HGit.Core.Types.Blob)
                                                                  HGit.Core.Types.Blob)>_N) of ww { (,) ww1 ww2 ->
                 Runtime.RunCmd.$wc ww2 }) -}
a8e2f5e4843213486238c881c66def4a
  setDirTo_f ::
    Data.Functor.Foldable.Fix
      (Data.Functor.Compose.Compose
         (Merkle.Functors.HashAnnotated
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
         (Data.Functor.Compose.Compose
            (Control.Monad.Trans.Reader.ReaderT
               (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
            HGit.Core.Types.Blob))
    -> Control.Monad.Trans.Reader.ReaderT
         (Runtime.Capabilities.RepoCaps GHC.Types.IO)
         GHC.Types.IO
         (Data.Functor.Foldable.Fix
            (Data.Functor.Compose.Compose
               (Merkle.Functors.HashAnnotated
                  Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
               HGit.Core.Types.Blob))
  {- Unfolding: (Merkle.Store.Deref.strictDeref
                   @ HGit.Core.Types.Blob
                   @ (Control.Monad.Trans.Reader.ReaderT
                        (Runtime.Capabilities.RepoCaps GHC.Types.IO) GHC.Types.IO)
                   @ Merkle.Types.IPFS.RawIPFSHash
                   HGit.Core.Types.$fTraversableBlob
                   (Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT
                      @ (Runtime.Capabilities.RepoCaps GHC.Types.IO))) -}
68e4a00b928abd27efcfdf58a9bc7af1
  status ::
    Control.Monad.Trans.Reader.ReaderT
      (Runtime.Capabilities.RepoCaps GHC.Types.IO)
      GHC.Types.IO
      [([HGit.Core.Types.PartialFilePath], HGit.Core.Diff.Diff)]
  {- Arity: 2,
     Strictness: <S(S(LLS(S(C(C(S(SS))))L))S(SS)L),1*U(1*U(U(U,U(U)),U(U(U),U(U)),1*U(1*U(U),U)),1*U(U,U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Runtime.RunCmd.status1
                  `cast`
                ((<Runtime.Capabilities.RepoCaps GHC.Types.IO>_R
                  ->_R Sym (GHC.Types.N:IO[0]
                                <[([HGit.Core.Types.PartialFilePath],
                                   HGit.Core.Diff.Diff)]>_R)) ; Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                                         <Type>_N
                                                                         <Runtime.Capabilities.RepoCaps
                                                                            GHC.Types.IO>_R
                                                                         <GHC.Types.IO>_R
                                                                         <[([HGit.Core.Types.PartialFilePath],
                                                                            HGit.Core.Diff.Diff)]>_N)) -}
8fdb8777e93543b14bafa511ed025845
  status1 ::
    Runtime.Capabilities.RepoCaps GHC.Types.IO
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [([HGit.Core.Types.PartialFilePath], HGit.Core.Diff.Diff)] #)
  {- Arity: 2,
     Strictness: <S(S(LLS(S(C(C(S(SS))))L))S(SS)L),1*U(1*U(U(U,U(U)),U(U(U),U(U)),1*U(1*U(U),U)),1*U(U,U),U)><S,U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Runtime.Capabilities.RepoCaps GHC.Types.IO)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { Runtime.Capabilities.RepoCaps ww1 ww2 ww3 ->
                 case ww1 of ww4 { Runtime.Capabilities.HgitStore ww5 ww6 ww7 ->
                 case ww7 of ww8 { (,) ww9 ww10 ->
                 case ww9 of ww11 { Merkle.Store.GetCapability ww12 ->
                 case ww2 of ww13 { Runtime.Types.RepoState ww14 ww15 ->
                 Runtime.RunCmd.$wstatus
                   ww5
                   ww6
                   ww12
                   ww10
                   ww14
                   ww15
                   ww3
                   w2 } } } } }) -}
"SPEC/Runtime.RunCmd $fApplicativeReaderT @ IO _" [orphan] forall @ r
                                                                  (v :: GHC.Base.Applicative
                                                                          GHC.Types.IO)
  Control.Monad.Trans.Reader.$fApplicativeReaderT @ GHC.Types.IO
                                                  @ r
                                                  v
  = Runtime.RunCmd.$s$fApplicativeReaderT @ r
"SPEC/Runtime.RunCmd $fApplicativeReaderT_$c*> @ IO _" [orphan] forall @ r
                                                                       ($dApplicative :: GHC.Base.Applicative
                                                                                           GHC.Types.IO)
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c*> @ GHC.Types.IO
                                                       @ r
                                                       $dApplicative
  = Runtime.RunCmd.$s$fApplicativeReaderT_$s$fApplicativeReaderT_$c*>
      @ r
"SPEC/Runtime.RunCmd $fApplicativeReaderT_$c<* @ IO _" [orphan] forall @ r
                                                                       ($dApplicative :: GHC.Base.Applicative
                                                                                           GHC.Types.IO)
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<* @ GHC.Types.IO
                                                       @ r
                                                       $dApplicative
  = Runtime.RunCmd.$s$fApplicativeReaderT_$s$fApplicativeReaderT_$c<*
      @ r
"SPEC/Runtime.RunCmd $fApplicativeReaderT_$c<*> @ IO _" [orphan] forall @ r
                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                            GHC.Types.IO)
  Control.Monad.Trans.Reader.$fApplicativeReaderT_$c<*> @ GHC.Types.IO
                                                        @ r
                                                        $dApplicative
  = Runtime.RunCmd.$s$fApplicativeReaderT_$s$fApplicativeReaderT_$c<*>
      @ r
"SPEC/Runtime.RunCmd $fEqConst @ RawIPFSHash _ _" [orphan] forall @ k
                                                                  @ b :: k
                                                                  (v :: GHC.Classes.Eq
                                                                          Merkle.Types.IPFS.RawIPFSHash)
  Data.Functor.Const.$fEqConst @ Merkle.Types.IPFS.RawIPFSHash
                               @ k
                               @ b
                               v
  = Runtime.RunCmd.$s$fEqConst @ k @ b
"SPEC/Runtime.RunCmd $fFunctorReaderT @ IO _" [orphan] forall @ r
                                                              (v :: GHC.Base.Functor GHC.Types.IO)
  Control.Monad.Trans.Reader.$fFunctorReaderT @ GHC.Types.IO @ r v
  = Runtime.RunCmd.$s$fApplicativeReaderT_$s$fFunctorReaderT @ r
"SPEC/Runtime.RunCmd $fFunctorReaderT_$c<$ @ IO _" [orphan] forall @ r
                                                                   ($dFunctor :: GHC.Base.Functor
                                                                                   GHC.Types.IO)
  Control.Monad.Trans.Reader.$fFunctorReaderT_$c<$ @ GHC.Types.IO
                                                   @ r
                                                   $dFunctor
  = Runtime.RunCmd.$s$fApplicativeReaderT_$s$fFunctorReaderT_$c<$ @ r
"SPEC/Runtime.RunCmd $fFunctorReaderT_$cfmap @ IO _" [orphan] forall @ r
                                                                     ($dFunctor :: GHC.Base.Functor
                                                                                     GHC.Types.IO)
  Control.Monad.Trans.Reader.$fFunctorReaderT_$cfmap @ GHC.Types.IO
                                                     @ r
                                                     $dFunctor
  = Runtime.RunCmd.$s$fApplicativeReaderT_$s$fFunctorReaderT_$cfmap
      @ r
"SPEC/Runtime.RunCmd $fMonadIOReaderT @ IO _" [orphan] forall @ r
                                                              (v :: Control.Monad.IO.Class.MonadIO
                                                                      GHC.Types.IO)
  Control.Monad.Trans.Reader.$fMonadIOReaderT @ GHC.Types.IO @ r v
  = Runtime.RunCmd.$s$fMonadIOReaderT @ r
"SPEC/Runtime.RunCmd $fMonadReaderT @ IO _" [orphan] forall @ r
                                                            (v :: GHC.Base.Monad GHC.Types.IO)
  Control.Monad.Trans.Reader.$fMonadReaderT @ GHC.Types.IO @ r v
  = Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT @ r
"SPEC/Runtime.RunCmd $fMonadReaderT_$c>>= @ IO _" [orphan] forall @ r
                                                                  ($dMonad :: GHC.Base.Monad
                                                                                GHC.Types.IO)
  Control.Monad.Trans.Reader.$fMonadReaderT_$c>>= @ GHC.Types.IO
                                                  @ r
                                                  $dMonad
  = Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT_$c>>= @ r
"SPEC/Runtime.RunCmd $fMonadReaderT_$cfail @ IO _" [orphan] forall @ r
                                                                   ($dMonad :: GHC.Base.Monad
                                                                                 GHC.Types.IO)
  Control.Monad.Trans.Reader.$fMonadReaderT_$cfail @ GHC.Types.IO
                                                   @ r
                                                   $dMonad
  = Runtime.RunCmd.$s$fMonadIOReaderT_$s$fMonadReaderT_$cfail @ r
"SPEC/Runtime.RunCmd $fMonadThrowReaderT @ IO _" [orphan] forall @ r
                                                                 (v :: Control.Monad.Catch.MonadThrow
                                                                         GHC.Types.IO)
  Control.Monad.Catch.$fMonadThrowReaderT @ GHC.Types.IO @ r v
  = Runtime.RunCmd.$s$fMonadThrowReaderT @ r
"SPEC/Runtime.RunCmd $fToJSONConst_$ctoJSON _ @ RawIPFSHash _" [orphan] forall @ k
                                                                               @ b :: k
                                                                               ($dToJSON :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                              Merkle.Types.IPFS.RawIPFSHash)
  Data.Aeson.Types.ToJSON.$fToJSONConst_$ctoJSON @ k
                                                 @ Merkle.Types.IPFS.RawIPFSHash
                                                 @ b
                                                 $dToJSON
  = Runtime.RunCmd.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON @ k @ b
"SPEC/Runtime.RunCmd $fToJSONf @ (Commit
                                   (Hash HashableDir)) @ (Const
                                                            RawIPFSHash (Commit (Hash HashableDir)))" [orphan] forall (v1 :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                                                                                                                                                                        (Data.Functor.Const.Const
                                                                                                                                                                                                                                           Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                                                                                                           (HGit.Core.Types.Commit
                                                                                                                                                                                                                                              (HGit.Core.Types.Hash
                                                                                                                                                                                                                                                 HGit.Core.Types.HashableDir))))
                                                                                                                                                                                                                               (v :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                                                                                                                                                                       (HGit.Core.Types.Commit
                                                                                                                                                                                                                                          (HGit.Core.Types.Hash
                                                                                                                                                                                                                                             HGit.Core.Types.HashableDir)))
  Data.Aeson.Orphans.$fToJSONf @ (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                               @ (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash
                                    (HGit.Core.Types.Commit
                                       (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                               v
                               v1
  = Runtime.RunCmd.$s$fToJSONf
"SPEC/Runtime.RunCmd $fToJSONf_$ctoJSON @ (Commit
                                            (Hash HashableDir)) @ (Const
                                                                     RawIPFSHash
                                                                     (Commit (Hash HashableDir)))" [orphan] forall ($dToJSON :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                                                                                                                                                                                                                                                                              (Data.Functor.Const.Const
                                                                                                                                                                                                                                                                                                                                                 Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                                                                                                                                                                                                                 (HGit.Core.Types.Commit
                                                                                                                                                                                                                                                                                                                                                    (HGit.Core.Types.Hash
                                                                                                                                                                                                                                                                                                                                                       HGit.Core.Types.HashableDir))))
                                                                                                                                                                                                                                                                                                                               ($dToJSON1 :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                                                                                                                                                                                                                                                                               (HGit.Core.Types.Commit
                                                                                                                                                                                                                                                                                                                                                  (HGit.Core.Types.Hash
                                                                                                                                                                                                                                                                                                                                                     HGit.Core.Types.HashableDir)))
  Data.Aeson.Orphans.$fToJSONf_$ctoJSON @ (HGit.Core.Types.Commit
                                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                        $dToJSON1
                                        $dToJSON
  = Runtime.RunCmd.$s$fToJSONf_$ctoJSON
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

