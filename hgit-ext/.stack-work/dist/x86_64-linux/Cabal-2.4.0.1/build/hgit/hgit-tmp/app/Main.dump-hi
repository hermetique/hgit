
==================== FINAL INTERFACE ====================
2019-05-20 21:44:01.347049775 UTC

interface main:Main 8063
  interface hash: 9c2bcebf4b39ff2baeecb42a7876c574
  ABI hash: c96378a5d9b6a79fce2b09933486470c
  export-list hash: 5949899cda6f42fe818ac02cd489c432
  orphan hash: 7f41faf2bdc87e204c4b2870ebef28cd
  flag hash: 1d40da92a3b26ef7c689145bd92b87a1
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.main
module dependencies: Runtime.Capabilities Runtime.Commands
                     Runtime.FileIO Runtime.RunCmd Runtime.Types
package dependencies: RSA-2.3.1 SHA-1.6.4.4 StateVar-1.1.1.1
                      adjunctions-4.4 aeson-1.4.2.0 ansi-terminal-0.8.2
                      ansi-wl-pprint-0.6.8.2 array-0.5.3.0 asn1-encoding-0.9.5
                      asn1-parse-0.9.4 asn1-types-0.3.2 async-2.2.1 attoparsec-0.13.2.2
                      authenticate-oauth-1.6 base-4.12.0.0 base-compat-0.10.5
                      base-orphans-0.8 base16-bytestring-0.1.1.6
                      base64-bytestring-1.0.0.2 basement-0.0.10 bifunctors-5.5.3
                      binary-0.8.6.0 blaze-builder-0.4.1.0 bytestring-0.10.8.2
                      call-stack-0.1.0 case-insensitive-1.2.0.11 cereal-0.5.8.0
                      colour-2.3.4 comonad-5.0.4 connection-0.2.8 containers-0.6.0.1
                      contravariant-1.5 cookie-0.4.4 crypto-api-0.13.3
                      crypto-pubkey-types-0.4.3 cryptonite-0.25 data-default-0.7.1.1
                      data-default-class-0.1.2.0 data-default-instances-containers-0.0.1
                      data-default-instances-dlist-0.0.1
                      data-default-instances-old-locale-0.0.1 deepseq-1.4.4.0
                      deriving-compat-0.5.4 directory-1.3.3.0 distributive-0.6
                      dlist-0.8.0.5 entropy-0.4.1.4 exceptions-0.10.0 filepath-1.4.2.1
                      free-5.1 ghc-boot-th-8.6.3 ghc-prim-0.5.3 hashable-1.2.7.0
                      hgit-0.1.0.0 hourglass-0.2.12 http-client-0.5.14
                      http-client-tls-0.3.5.3 http-types-0.12.2 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.2.2 kan-extensions-5.2 lens-4.17
                      lens-aeson-1.0.2 memory-0.14.18 merkle-schemes-0.1.0.0
                      merkle-schemes-ext-0.1.0.0 mime-types-0.1.0.9 mtl-2.2.2
                      network-2.8.0.0 network-uri-2.6.1.0 old-locale-1.0.0.7
                      optparse-applicative-0.14.3.0 parsec-3.1.13.0 pem-0.2.4
                      pretty-1.1.3.6 primitive-0.6.4.0 process-1.6.3.0 profunctors-5.3
                      random-1.1 recursion-schemes-5.1.1 reflection-2.1.4
                      safe-exceptions-0.1.7.0 scientific-0.3.6.2 semigroupoids-5.3.2
                      socks-0.5.6 stm-2.5.0.0 streaming-commons-0.2.1.0 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 th-abstraction-0.2.10.0
                      time-1.8.0.2 time-locale-compat-0.1.1.5 tls-1.4.1
                      transformers-0.5.5.0 transformers-base-0.4.5.2
                      transformers-compat-0.6.2 unix-2.7.2.2 unordered-containers-0.2.9.0
                      uuid-types-1.0.3 vector-0.12.0.2 wreq-0.5.3.1 x509-1.7.5
                      x509-store-1.6.7 x509-system-1.6.6 x509-validation-1.6.11
                      zlib-0.6.2
orphans: merkle-schemes-0.1.0.0:Data.Aeson.Orphans
         colour-2.3.4:Data.Colour lens-aeson-1.0.2:Data.Aeson.Lens
         data-default-instances-containers-0.0.1:Data.Default.Instances.Containers
         data-default-instances-dlist-0.0.1:Data.Default.Instances.DList
         data-default-instances-old-locale-0.0.1:Data.Default.Instances.OldLocale
         RSA-2.3.1:Codec.Crypto.RSA.Pure wreq-0.5.3.1:Network.Wreq.Types
         reflection-2.1.4:Data.Reflection
         http-client-0.5.14:Network.HTTP.Client.Request
         basement-0.0.10:Basement.UArray.Base basement-0.0.10:Basement.Block
         network-2.8.0.0:Network.Socket
         attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         vector-0.12.0.2:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         vector-0.12.0.2:Data.Vector.Fusion.Bundle
         stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.5.0:Control.Monad.Trans.Error
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: adjunctions-4.4:Data.Functor.Rep
                         aeson-1.4.2.0:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         basement-0.0.10:Basement.Block.Base
                         basement-0.0.10:Basement.Bounded basement-0.0.10:Basement.Monad
                         basement-0.0.10:Basement.MutableBuilder
                         basement-0.0.10:Basement.Nat basement-0.0.10:Basement.NonEmpty
                         basement-0.0.10:Basement.Numerical.Subtractive
                         basement-0.0.10:Basement.PrimType basement-0.0.10:Basement.String
                         basement-0.0.10:Basement.String.Encoding.ASCII7
                         basement-0.0.10:Basement.String.Encoding.ISO_8859_1
                         basement-0.0.10:Basement.String.Encoding.UTF16
                         basement-0.0.10:Basement.String.Encoding.UTF32
                         basement-0.0.10:Basement.Types.OffsetSize
                         basement-0.0.10:Basement.UArray.Base
                         basement-0.0.10:Basement.UTF8.Base
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Fix
                         bifunctors-5.5.3:Data.Bifunctor.Flip
                         bifunctors-5.5.3:Data.Bifunctor.Join
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         bifunctors-5.5.3:Data.Bifunctor.Wrapped
                         containers-0.6.0.1:Data.Graph
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         cryptonite-0.25:Crypto.ECC cryptonite-0.25:Crypto.Error.Types
                         cryptonite-0.25:Crypto.Hash.Blake2
                         cryptonite-0.25:Crypto.Hash.Blake2b
                         cryptonite-0.25:Crypto.Hash.Blake2bp
                         cryptonite-0.25:Crypto.Hash.Blake2s
                         cryptonite-0.25:Crypto.Hash.Blake2sp
                         cryptonite-0.25:Crypto.Hash.Keccak cryptonite-0.25:Crypto.Hash.MD2
                         cryptonite-0.25:Crypto.Hash.MD4 cryptonite-0.25:Crypto.Hash.MD5
                         cryptonite-0.25:Crypto.Hash.RIPEMD160
                         cryptonite-0.25:Crypto.Hash.SHA1 cryptonite-0.25:Crypto.Hash.SHA224
                         cryptonite-0.25:Crypto.Hash.SHA256 cryptonite-0.25:Crypto.Hash.SHA3
                         cryptonite-0.25:Crypto.Hash.SHA384
                         cryptonite-0.25:Crypto.Hash.SHA512
                         cryptonite-0.25:Crypto.Hash.SHA512t
                         cryptonite-0.25:Crypto.Hash.SHAKE
                         cryptonite-0.25:Crypto.Hash.Skein256
                         cryptonite-0.25:Crypto.Hash.Skein512
                         cryptonite-0.25:Crypto.Hash.Tiger
                         cryptonite-0.25:Crypto.Hash.Whirlpool dlist-0.8.0.5:Data.DList
                         free-5.1:Control.Comonad.Cofree
                         free-5.1:Control.Comonad.Trans.Cofree free-5.1:Control.Monad.Free
                         free-5.1:Control.Monad.Trans.Free
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         hgit-0.1.0.0:HGit.Core.Types http-client-0.5.14:Network.HTTP.Client
                         kan-extensions-5.2:Data.Functor.Day
                         kan-extensions-5.2:Data.Functor.Yoneda lens-4.17:Control.Lens.At
                         lens-4.17:Control.Lens.Internal.Indexed
                         lens-4.17:Control.Lens.Reified lens-4.17:Control.Lens.Tuple
                         lens-4.17:Control.Lens.Wrapped lens-4.17:Control.Lens.Zoom
                         lens-aeson-1.0.2:Data.Aeson.Lens main:Runtime.Types
                         merkle-schemes-0.1.0.0:Merkle.Types.IPFS
                         network-uri-2.6.1.0:Network.URI
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         profunctors-5.3:Data.Profunctor.Composition
                         profunctors-5.3:Data.Profunctor.Rep
                         recursion-schemes-5.1.1:Data.Functor.Base
                         recursion-schemes-5.1.1:Data.Functor.Foldable
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         th-abstraction-0.2.10.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.2:Data.Vector vector-0.12.0.2:Data.Vector.Primitive
                         vector-0.12.0.2:Data.Vector.Storable
                         vector-0.12.0.2:Data.Vector.Unboxed
                         vector-0.12.0.2:Data.Vector.Unboxed.Base
                         zlib-0.6.2:Codec.Compression.Zlib.Stream
import  -/  base-4.12.0.0:Data.Either 946a3435d06773e1dbcad1ba5dc18a2c
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  Runtime.Capabilities 27549094e78df9f7af431ec023777ab6
  exports: 40f7120a5ece4cdaee8d81f0d3967551
  HgitStore 44b40918ec6716f0a5b2789750a2918f
  RepoCaps 609f65eef07c3c2be07eb43ee9e243f5
  hgitBaseDir d5a66592bd6cbba056cc51bd21428d74
  readState 95b5eb7d90341e29bbc2bb53354cf2e9
  writeState 97a141d96b135681a392cec9201607bd
import  -/  Runtime.Commands b6c5de75f4557f872e827c2d9ff81a00
  exports: ddf5af81328c4defe5ed0e9877790537
  InitRepo 7738c4c6c0620b225f9b6df443f65312
  parse 0ae4a0eec4a727049f4c7aef513971b7
import  -/  Runtime.RunCmd 5571907718e5a61438ea5bddb779a85e
  exports: 7fbcd3cff961e04b34a322cc02b01044
  initRepo 2f74630620d08385904ec164af7f5ed3
  runCommand 1b6adc2f9be8a74a23a9601f1ca8ae3d
import  -/  merkle-schemes-0.1.0.0:Merkle.Store e36594001decc0fe1d4e174b93d02572
import  -/  merkle-schemes-ext-0.1.0.0:Merkle.Store.IPFS f31cc191599763028ee09446484660d4
import  -/  mtl-2.2.2:Control.Monad.Reader d851fb94eb94072f491282515418f996
import  -/  transformers-0.5.5.0:Control.Monad.Trans.Reader 3d5c6b0df34d74144ad9d24efee0de98
ef43150ced7f5e01b030d9dd4e5ec217
  $s$fFromJSONConst ::
    forall k (b :: k).
    Data.Aeson.Types.FromJSON.FromJSON
      (Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ k @ b :: k.
                  @ (Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b)
                  (\ (x :: Data.Aeson.Types.Internal.Value) ->
                   let {
                     m :: Data.Aeson.Types.Internal.Parser Merkle.Types.IPFS.RawIPFSHash
                     = case x of wild {
                         DEFAULT
                         -> let {
                              msg20 :: GHC.Base.String
                              = GHC.CString.unpackAppendCString#
                                  Data.Aeson.Types.FromJSON.typeMismatch4
                                  (GHC.Base.augment
                                     @ GHC.Types.Char
                                     (\ @ b1
                                        (c :: GHC.Types.Char -> b1 -> b1)[OneShot]
                                        (n :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ GHC.Types.Char
                                        @ b1
                                        c
                                        n
                                        Merkle.Types.IPFS.$fFromJSONRawIPFSHash2)
                                     (GHC.CString.unpackAppendCString#
                                        Data.Aeson.Types.FromJSON.typeMismatch3
                                        (case wild of wild1 {
                                           Data.Aeson.Types.Internal.Object ds
                                           -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList10
                                           Data.Aeson.Types.Internal.Array ds
                                           -> Data.Aeson.Types.FromJSON.typeMismatch1
                                           Data.Aeson.Types.Internal.Number ds
                                           -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList6
                                           Data.Aeson.Types.Internal.Bool ds
                                           -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList4
                                           Data.Aeson.Types.Internal.Null
                                           -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList1 })))
                            } in
                            (\ @ f4 :: Type -> Type
                               @ r
                               (path :: Data.Aeson.Types.Internal.JSONPath)
                               (kf :: Data.Aeson.Types.Internal.Failure f4 r)
                               (_ks :: Data.Aeson.Types.Internal.Success
                                         Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                             kf
                               (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                               msg20)
                              `cast`
                            (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                      <Merkle.Types.IPFS.RawIPFSHash>_R))
                         Data.Aeson.Types.Internal.String txt
                         -> (\ @ f4 :: Type -> Type
                               @ r
                               (_path :: Data.Aeson.Types.Internal.JSONPath)
                               (_kf :: Data.Aeson.Types.Internal.Failure f4 r)
                               (ks :: Data.Aeson.Types.Internal.Success
                                        Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                             ks txt `cast` (Sym (Merkle.Types.IPFS.N:RawIPFSHash[0])))
                              `cast`
                            (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                      <Merkle.Types.IPFS.RawIPFSHash>_R)) }
                   } in
                   (\ @ f5 :: Type -> Type
                      @ r
                      (path :: Data.Aeson.Types.Internal.JSONPath)
                      (kf :: Data.Aeson.Types.Internal.Failure f5 r)
                      (ks :: Data.Aeson.Types.Internal.Success
                               (Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b) f5 r) ->
                    m `cast`
                    (Data.Aeson.Types.Internal.N:Parser[0]
                         <Merkle.Types.IPFS.RawIPFSHash>_R)
                      @ f5
                      @ r
                      path
                      kf
                      (\ (a1 :: Merkle.Types.IPFS.RawIPFSHash) ->
                       ks
                         a1
                           `cast`
                         (Sym (Data.Functor.Const.N:Const[0]
                                   <k>_N <Merkle.Types.IPFS.RawIPFSHash>_R <b>_P))))
                     `cast`
                   (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                             <Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b>_R)))
                  (Data.Aeson.Types.FromJSON.$fFromJSONConst_$cparseJSONList
                     @ k
                     @ Merkle.Types.IPFS.RawIPFSHash
                     @ b
                     Merkle.Types.IPFS.$fFromJSONRawIPFSHash) -}
c7931bc4ecf0401dce2fccccf55722fa
  $s$fFromJSONf ::
    Data.Aeson.Types.FromJSON.FromJSON
      (HGit.Core.Types.Blob
         (Data.Functor.Const.Const
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (HGit.Core.Types.Blob
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                  (HGit.Core.Types.$fFromJSON1Blob_$cliftParseJSON
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                     (\ (x :: Data.Aeson.Types.Internal.Value) ->
                      let {
                        m :: Data.Aeson.Types.Internal.Parser Merkle.Types.IPFS.RawIPFSHash
                        = case x of wild {
                            DEFAULT
                            -> let {
                                 msg20 :: GHC.Base.String
                                 = GHC.CString.unpackAppendCString#
                                     Data.Aeson.Types.FromJSON.typeMismatch4
                                     (GHC.Base.augment
                                        @ GHC.Types.Char
                                        (\ @ b
                                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                                           (n :: b)[OneShot] ->
                                         GHC.Base.foldr
                                           @ GHC.Types.Char
                                           @ b
                                           c
                                           n
                                           Merkle.Types.IPFS.$fFromJSONRawIPFSHash2)
                                        (GHC.CString.unpackAppendCString#
                                           Data.Aeson.Types.FromJSON.typeMismatch3
                                           (case wild of wild1 {
                                              Data.Aeson.Types.Internal.Object ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList10
                                              Data.Aeson.Types.Internal.Array ds
                                              -> Data.Aeson.Types.FromJSON.typeMismatch1
                                              Data.Aeson.Types.Internal.Number ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList6
                                              Data.Aeson.Types.Internal.Bool ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList4
                                              Data.Aeson.Types.Internal.Null
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList1 })))
                               } in
                               (\ @ f4 :: Type -> Type
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f4 r)
                                  (_ks :: Data.Aeson.Types.Internal.Success
                                            Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                                kf
                                  (GHC.List.reverse
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     path)
                                  msg20)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Merkle.Types.IPFS.RawIPFSHash>_R))
                            Data.Aeson.Types.Internal.String txt
                            -> (\ @ f4 :: Type -> Type
                                  @ r
                                  (_path :: Data.Aeson.Types.Internal.JSONPath)
                                  (_kf :: Data.Aeson.Types.Internal.Failure f4 r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                                ks txt `cast` (Sym (Merkle.Types.IPFS.N:RawIPFSHash[0])))
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Merkle.Types.IPFS.RawIPFSHash>_R)) }
                      } in
                      (\ @ f5 :: Type -> Type
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f5 r)
                         (ks :: Data.Aeson.Types.Internal.Success
                                  (Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                  f5
                                  r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0]
                            <Merkle.Types.IPFS.RawIPFSHash>_R)
                         @ f5
                         @ r
                         path
                         kf
                         (\ (a1 :: Merkle.Types.IPFS.RawIPFSHash) ->
                          ks
                            a1
                              `cast`
                            (Sym (Data.Functor.Const.N:Const[0]
                                      <Type -> Type>_N
                                      <Merkle.Types.IPFS.RawIPFSHash>_R
                                      <HGit.Core.Types.Blob>_P))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Data.Functor.Const.Const
                                   Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob>_R)))
                     (Data.Aeson.Types.FromJSON.$fFromJSONConst_$cparseJSONList
                        @ (Type -> Type)
                        @ Merkle.Types.IPFS.RawIPFSHash
                        @ HGit.Core.Types.Blob
                        Merkle.Types.IPFS.$fFromJSONRawIPFSHash))
                  (Data.Aeson.Orphans.$fFromJSONf_$cparseJSONList
                     @ HGit.Core.Types.Blob
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                     HGit.Core.Types.$fFromJSON1Blob
                     (Main.$s$fFromJSONConst
                        @ (Type -> Type)
                        @ HGit.Core.Types.Blob)) -}
78d7fe03e25b7436f2f160518d64dbfa
  $s$fFromJSONf1 ::
    Data.Aeson.Types.FromJSON.FromJSON
      (HGit.Core.Types.Dir
         (HGit.Core.Types.Hash HGit.Core.Types.Blob)
         (Data.Functor.Const.Const
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (HGit.Core.Types.Dir
                       (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir))
                  (HGit.Core.Types.$fFromJSON1Dir_$cliftParseJSON
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                     (\ (x :: Data.Aeson.Types.Internal.Value) ->
                      let {
                        m :: Data.Aeson.Types.Internal.Parser Merkle.Types.IPFS.RawIPFSHash
                        = case x of wild {
                            DEFAULT
                            -> let {
                                 msg20 :: GHC.Base.String
                                 = GHC.CString.unpackAppendCString#
                                     Data.Aeson.Types.FromJSON.typeMismatch4
                                     (GHC.Base.augment
                                        @ GHC.Types.Char
                                        (\ @ b
                                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                                           (n :: b)[OneShot] ->
                                         GHC.Base.foldr
                                           @ GHC.Types.Char
                                           @ b
                                           c
                                           n
                                           Merkle.Types.IPFS.$fFromJSONRawIPFSHash2)
                                        (GHC.CString.unpackAppendCString#
                                           Data.Aeson.Types.FromJSON.typeMismatch3
                                           (case wild of wild1 {
                                              Data.Aeson.Types.Internal.Object ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList10
                                              Data.Aeson.Types.Internal.Array ds
                                              -> Data.Aeson.Types.FromJSON.typeMismatch1
                                              Data.Aeson.Types.Internal.Number ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList6
                                              Data.Aeson.Types.Internal.Bool ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList4
                                              Data.Aeson.Types.Internal.Null
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList1 })))
                               } in
                               (\ @ f4 :: Type -> Type
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f4 r)
                                  (_ks :: Data.Aeson.Types.Internal.Success
                                            Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                                kf
                                  (GHC.List.reverse
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     path)
                                  msg20)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Merkle.Types.IPFS.RawIPFSHash>_R))
                            Data.Aeson.Types.Internal.String txt
                            -> (\ @ f4 :: Type -> Type
                                  @ r
                                  (_path :: Data.Aeson.Types.Internal.JSONPath)
                                  (_kf :: Data.Aeson.Types.Internal.Failure f4 r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                                ks txt `cast` (Sym (Merkle.Types.IPFS.N:RawIPFSHash[0])))
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Merkle.Types.IPFS.RawIPFSHash>_R)) }
                      } in
                      (\ @ f5 :: Type -> Type
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f5 r)
                         (ks :: Data.Aeson.Types.Internal.Success
                                  (Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash
                                     (HGit.Core.Types.Dir
                                        (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                  f5
                                  r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0]
                            <Merkle.Types.IPFS.RawIPFSHash>_R)
                         @ f5
                         @ r
                         path
                         kf
                         (\ (a1 :: Merkle.Types.IPFS.RawIPFSHash) ->
                          ks
                            a1
                              `cast`
                            (Sym (Data.Functor.Const.N:Const[0]
                                      <Type -> Type>_N
                                      <Merkle.Types.IPFS.RawIPFSHash>_R
                                      <HGit.Core.Types.Dir
                                         (HGit.Core.Types.Hash HGit.Core.Types.Blob)>_P))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Data.Functor.Const.Const
                                   Merkle.Types.IPFS.RawIPFSHash
                                   (HGit.Core.Types.Dir
                                      (HGit.Core.Types.Hash HGit.Core.Types.Blob))>_R)))
                     (Data.Aeson.Types.FromJSON.$fFromJSONConst_$cparseJSONList
                        @ (Type -> Type)
                        @ Merkle.Types.IPFS.RawIPFSHash
                        @ (HGit.Core.Types.Dir (HGit.Core.Types.Hash HGit.Core.Types.Blob))
                        Merkle.Types.IPFS.$fFromJSONRawIPFSHash))
                  (Data.Aeson.Orphans.$fFromJSONf_$cparseJSONList
                     @ (HGit.Core.Types.Dir (HGit.Core.Types.Hash HGit.Core.Types.Blob))
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                     HGit.Core.Types.$fFromJSON1Dir
                     (Main.$s$fFromJSONConst
                        @ (Type -> Type)
                        @ (HGit.Core.Types.Dir
                             (HGit.Core.Types.Hash HGit.Core.Types.Blob)))) -}
9330e65260a83da44d133f798c222c50
  $s$fFromJSONf2 ::
    Data.Aeson.Types.FromJSON.FromJSON
      (HGit.Core.Types.Commit
         (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
         (Data.Functor.Const.Const
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (HGit.Core.Types.Commit
                       (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit))
                  (HGit.Core.Types.$fFromJSON1Commit_$cliftParseJSON
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                     (\ (x :: Data.Aeson.Types.Internal.Value) ->
                      let {
                        m :: Data.Aeson.Types.Internal.Parser Merkle.Types.IPFS.RawIPFSHash
                        = case x of wild {
                            DEFAULT
                            -> let {
                                 msg20 :: GHC.Base.String
                                 = GHC.CString.unpackAppendCString#
                                     Data.Aeson.Types.FromJSON.typeMismatch4
                                     (GHC.Base.augment
                                        @ GHC.Types.Char
                                        (\ @ b
                                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                                           (n :: b)[OneShot] ->
                                         GHC.Base.foldr
                                           @ GHC.Types.Char
                                           @ b
                                           c
                                           n
                                           Merkle.Types.IPFS.$fFromJSONRawIPFSHash2)
                                        (GHC.CString.unpackAppendCString#
                                           Data.Aeson.Types.FromJSON.typeMismatch3
                                           (case wild of wild1 {
                                              Data.Aeson.Types.Internal.Object ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList10
                                              Data.Aeson.Types.Internal.Array ds
                                              -> Data.Aeson.Types.FromJSON.typeMismatch1
                                              Data.Aeson.Types.Internal.Number ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList6
                                              Data.Aeson.Types.Internal.Bool ds
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList4
                                              Data.Aeson.Types.Internal.Null
                                              -> Data.Aeson.Types.FromJSON.$dmliftParseJSONList1 })))
                               } in
                               (\ @ f4 :: Type -> Type
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f4 r)
                                  (_ks :: Data.Aeson.Types.Internal.Success
                                            Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                                kf
                                  (GHC.List.reverse
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     path)
                                  msg20)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Merkle.Types.IPFS.RawIPFSHash>_R))
                            Data.Aeson.Types.Internal.String txt
                            -> (\ @ f4 :: Type -> Type
                                  @ r
                                  (_path :: Data.Aeson.Types.Internal.JSONPath)
                                  (_kf :: Data.Aeson.Types.Internal.Failure f4 r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           Merkle.Types.IPFS.RawIPFSHash f4 r) ->
                                ks txt `cast` (Sym (Merkle.Types.IPFS.N:RawIPFSHash[0])))
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Merkle.Types.IPFS.RawIPFSHash>_R)) }
                      } in
                      (\ @ f5 :: Type -> Type
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f5 r)
                         (ks :: Data.Aeson.Types.Internal.Success
                                  (Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash
                                     (HGit.Core.Types.Commit
                                        (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                  f5
                                  r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0]
                            <Merkle.Types.IPFS.RawIPFSHash>_R)
                         @ f5
                         @ r
                         path
                         kf
                         (\ (a1 :: Merkle.Types.IPFS.RawIPFSHash) ->
                          ks
                            a1
                              `cast`
                            (Sym (Data.Functor.Const.N:Const[0]
                                      <Type -> Type>_N
                                      <Merkle.Types.IPFS.RawIPFSHash>_R
                                      <HGit.Core.Types.Commit
                                         (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)>_P))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Data.Functor.Const.Const
                                   Merkle.Types.IPFS.RawIPFSHash
                                   (HGit.Core.Types.Commit
                                      (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))>_R)))
                     (Data.Aeson.Types.FromJSON.$fFromJSONConst_$cparseJSONList
                        @ (Type -> Type)
                        @ Merkle.Types.IPFS.RawIPFSHash
                        @ (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                        Merkle.Types.IPFS.$fFromJSONRawIPFSHash))
                  (Data.Aeson.Orphans.$fFromJSONf_$cparseJSONList
                     @ (HGit.Core.Types.Commit
                          (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                     HGit.Core.Types.$fFromJSON1Commit
                     (Main.$s$fFromJSONConst
                        @ (Type -> Type)
                        @ (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))) -}
6a43358fff9ba5b7e54a5fdf70f29fcc
  $s$fToJSONConst_$s$fToJSONConst_$ctoJSON ::
    forall k (b :: k).
    Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>m3,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ k
                   @ b :: k
                   (ds :: Data.Functor.Const.Const Merkle.Types.IPFS.RawIPFSHash b) ->
                 Data.Aeson.Types.Internal.$WString
                   ds
                     `cast`
                   (Data.Functor.Const.N:Const[0]
                        <k>_N
                        <Merkle.Types.IPFS.RawIPFSHash>_R
                        <b>_P ; Merkle.Types.IPFS.N:RawIPFSHash[0])) -}
6bbccbaa46e74f67b5e1c1bccd6d1c6e
  $s$fToJSONf ::
    Data.Aeson.Types.ToJSON.ToJSON
      (HGit.Core.Types.Blob
         (Data.Functor.Const.Const
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (HGit.Core.Types.Blob
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                  (HGit.Core.Types.$fToJSON1Blob_$cliftToJSON
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                     (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                        @ (Type -> Type)
                        @ HGit.Core.Types.Blob)
                     (\ (x :: [Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]) ->
                      Data.Aeson.Types.Internal.$WArray
                        (Data.Vector.Generic.new
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Generic.New.unstream
                              @ Data.Vector.Vector
                              @ Data.Aeson.Types.Internal.Value
                              (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                              (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                 @ Data.Vector.Fusion.Util.Id
                                 @ Data.Aeson.Types.Internal.Value
                                 @ Data.Vector.Vector
                                 Data.Vector.Fusion.Util.$fMonadId
                                 Data.Vector.Fusion.Bundle.Size.Unknown
                                 (GHC.Base.build
                                    @ Data.Aeson.Types.Internal.Value
                                    (\ @ b1
                                       (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                       (n1 :: b1)[OneShot] ->
                                     GHC.Base.foldr
                                       @ (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                       @ b1
                                       (GHC.Base.mapFB
                                          @ Data.Aeson.Types.Internal.Value
                                          @ b1
                                          @ (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                          c
                                          (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                             @ (Type -> Type)
                                             @ HGit.Core.Types.Blob))
                                       n1
                                       x)))))))
                  (let {
                     g :: [Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]
                          -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                           c
                                           (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ HGit.Core.Types.Blob))
                                        n1
                                        x)))))
                   } in
                   (\ (x :: HGit.Core.Types.Blob
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)) ->
                    Data.Aeson.Encoding.Builder.encodeToBuilder
                      (HGit.Core.Types.$fToJSON1Blob_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                         (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ HGit.Core.Types.Blob)
                         g
                         x))
                     `cast`
                   (<HGit.Core.Types.Blob
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)>_R
                    ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                  <Data.Aeson.Types.Internal.Value>_P)))
                  (let {
                     f5 :: [Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                           c
                                           (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ HGit.Core.Types.Blob))
                                        n1
                                        x)))))
                   } in
                   let {
                     f1 :: HGit.Core.Types.Blob
                             (Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = HGit.Core.Types.$fToJSON1Blob_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                         (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ HGit.Core.Types.Blob)
                         f5
                   } in
                   \ (x :: [HGit.Core.Types.Blob
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)]) ->
                   Data.Aeson.Types.Internal.$WArray
                     (Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n1 :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ (HGit.Core.Types.Blob
                                         (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ (HGit.Core.Types.Blob
                                            (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                                       c
                                       f1)
                                    n1
                                    x))))))
                  (Data.Aeson.Encoding.Internal.list
                     @ (HGit.Core.Types.Blob
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob))
                     (let {
                        g :: [Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]
                             -> Data.Aeson.Types.Internal.Value
                          {- Arity: 1 -}
                        = \ (x :: [Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]) ->
                          Data.Aeson.Types.Internal.$WArray
                            (Data.Vector.Generic.new
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Generic.New.unstream
                                  @ Data.Vector.Vector
                                  @ Data.Aeson.Types.Internal.Value
                                  (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                                  (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                     @ Data.Vector.Fusion.Util.Id
                                     @ Data.Aeson.Types.Internal.Value
                                     @ Data.Vector.Vector
                                     Data.Vector.Fusion.Util.$fMonadId
                                     Data.Vector.Fusion.Bundle.Size.Unknown
                                     (GHC.Base.build
                                        @ Data.Aeson.Types.Internal.Value
                                        (\ @ b1
                                           (c :: Data.Aeson.Types.Internal.Value
                                                 -> b1 -> b1)[OneShot]
                                           (n1 :: b1)[OneShot] ->
                                         GHC.Base.foldr
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                           @ b1
                                           (GHC.Base.mapFB
                                              @ Data.Aeson.Types.Internal.Value
                                              @ b1
                                              @ (Data.Functor.Const.Const
                                                   Merkle.Types.IPFS.RawIPFSHash
                                                   HGit.Core.Types.Blob)
                                              c
                                              (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                                 @ (Type -> Type)
                                                 @ HGit.Core.Types.Blob))
                                           n1
                                           x)))))
                      } in
                      (\ (x :: HGit.Core.Types.Blob
                                 (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)) ->
                       Data.Aeson.Encoding.Builder.encodeToBuilder
                         (HGit.Core.Types.$fToJSON1Blob_$cliftToJSON
                            @ (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                            (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                               @ (Type -> Type)
                               @ HGit.Core.Types.Blob)
                            g
                            x))
                        `cast`
                      (<HGit.Core.Types.Blob
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)>_R
                       ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                     <Data.Aeson.Types.Internal.Value>_P)))) -}
ad14520d8e41bcb3959c86af23ca0a1c
  $s$fToJSONf1 ::
    Data.Aeson.Types.ToJSON.ToJSON
      (HGit.Core.Types.Dir
         (HGit.Core.Types.Hash HGit.Core.Types.Blob)
         (Data.Functor.Const.Const
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (HGit.Core.Types.Dir
                       (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir))
                  (HGit.Core.Types.$fToJSON1Dir_$cliftToJSON
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                     (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                        @ (Type -> Type)
                        @ (HGit.Core.Types.Dir
                             (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                     (\ (x :: [Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash
                                 (HGit.Core.Types.Dir
                                    (HGit.Core.Types.Hash HGit.Core.Types.Blob))]) ->
                      Data.Aeson.Types.Internal.$WArray
                        (Data.Vector.Generic.new
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Generic.New.unstream
                              @ Data.Vector.Vector
                              @ Data.Aeson.Types.Internal.Value
                              (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                              (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                 @ Data.Vector.Fusion.Util.Id
                                 @ Data.Aeson.Types.Internal.Value
                                 @ Data.Vector.Vector
                                 Data.Vector.Fusion.Util.$fMonadId
                                 Data.Vector.Fusion.Bundle.Size.Unknown
                                 (GHC.Base.build
                                    @ Data.Aeson.Types.Internal.Value
                                    (\ @ b1
                                       (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                       (n1 :: b1)[OneShot] ->
                                     GHC.Base.foldr
                                       @ (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash
                                            (HGit.Core.Types.Dir
                                               (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                       @ b1
                                       (GHC.Base.mapFB
                                          @ Data.Aeson.Types.Internal.Value
                                          @ b1
                                          @ (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash
                                               (HGit.Core.Types.Dir
                                                  (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                          c
                                          (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                             @ (Type -> Type)
                                             @ (HGit.Core.Types.Dir
                                                  (HGit.Core.Types.Hash HGit.Core.Types.Blob))))
                                       n1
                                       x)))))))
                  (let {
                     g :: [Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash
                             (HGit.Core.Types.Dir (HGit.Core.Types.Hash HGit.Core.Types.Blob))]
                          -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash
                                  (HGit.Core.Types.Dir
                                     (HGit.Core.Types.Hash HGit.Core.Types.Blob))]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Dir
                                                (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Dir
                                                   (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                           c
                                           (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ (HGit.Core.Types.Dir
                                                   (HGit.Core.Types.Hash HGit.Core.Types.Blob))))
                                        n1
                                        x)))))
                   } in
                   (\ (x :: HGit.Core.Types.Dir
                              (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)) ->
                    Data.Aeson.Encoding.Builder.encodeToBuilder
                      (HGit.Core.Types.$fToJSON1Dir_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                         (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ (HGit.Core.Types.Dir
                                 (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                         g
                         x))
                     `cast`
                   (<HGit.Core.Types.Dir
                       (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)>_R
                    ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                  <Data.Aeson.Types.Internal.Value>_P)))
                  (let {
                     f5 :: [Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash
                              (HGit.Core.Types.Dir (HGit.Core.Types.Hash HGit.Core.Types.Blob))]
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash
                                  (HGit.Core.Types.Dir
                                     (HGit.Core.Types.Hash HGit.Core.Types.Blob))]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Dir
                                                (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Dir
                                                   (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                           c
                                           (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ (HGit.Core.Types.Dir
                                                   (HGit.Core.Types.Hash HGit.Core.Types.Blob))))
                                        n1
                                        x)))))
                   } in
                   let {
                     f1 :: HGit.Core.Types.Dir
                             (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                             (Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = HGit.Core.Types.$fToJSON1Dir_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                         (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ (HGit.Core.Types.Dir
                                 (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                         f5
                   } in
                   \ (x :: [HGit.Core.Types.Dir
                              (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)]) ->
                   Data.Aeson.Types.Internal.$WArray
                     (Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n1 :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ (HGit.Core.Types.Dir
                                         (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                                         (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash
                                            HGit.Core.Types.HashableDir))
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ (HGit.Core.Types.Dir
                                            (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                                            (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash
                                               HGit.Core.Types.HashableDir))
                                       c
                                       f1)
                                    n1
                                    x))))))
                  (Data.Aeson.Encoding.Internal.list
                     @ (HGit.Core.Types.Dir
                          (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir))
                     (let {
                        g :: [Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash
                                (HGit.Core.Types.Dir (HGit.Core.Types.Hash HGit.Core.Types.Blob))]
                             -> Data.Aeson.Types.Internal.Value
                          {- Arity: 1 -}
                        = \ (x :: [Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash
                                     (HGit.Core.Types.Dir
                                        (HGit.Core.Types.Hash HGit.Core.Types.Blob))]) ->
                          Data.Aeson.Types.Internal.$WArray
                            (Data.Vector.Generic.new
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Generic.New.unstream
                                  @ Data.Vector.Vector
                                  @ Data.Aeson.Types.Internal.Value
                                  (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                                  (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                     @ Data.Vector.Fusion.Util.Id
                                     @ Data.Aeson.Types.Internal.Value
                                     @ Data.Vector.Vector
                                     Data.Vector.Fusion.Util.$fMonadId
                                     Data.Vector.Fusion.Bundle.Size.Unknown
                                     (GHC.Base.build
                                        @ Data.Aeson.Types.Internal.Value
                                        (\ @ b1
                                           (c :: Data.Aeson.Types.Internal.Value
                                                 -> b1 -> b1)[OneShot]
                                           (n1 :: b1)[OneShot] ->
                                         GHC.Base.foldr
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Dir
                                                   (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                           @ b1
                                           (GHC.Base.mapFB
                                              @ Data.Aeson.Types.Internal.Value
                                              @ b1
                                              @ (Data.Functor.Const.Const
                                                   Merkle.Types.IPFS.RawIPFSHash
                                                   (HGit.Core.Types.Dir
                                                      (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                              c
                                              (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                                 @ (Type -> Type)
                                                 @ (HGit.Core.Types.Dir
                                                      (HGit.Core.Types.Hash HGit.Core.Types.Blob))))
                                           n1
                                           x)))))
                      } in
                      (\ (x :: HGit.Core.Types.Dir
                                 (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                                 (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)) ->
                       Data.Aeson.Encoding.Builder.encodeToBuilder
                         (HGit.Core.Types.$fToJSON1Dir_$cliftToJSON
                            @ (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                            (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                               @ (Type -> Type)
                               @ (HGit.Core.Types.Dir
                                    (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                            g
                            x))
                        `cast`
                      (<HGit.Core.Types.Dir
                          (HGit.Core.Types.Hash HGit.Core.Types.Blob)
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)>_R
                       ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                     <Data.Aeson.Types.Internal.Value>_P)))) -}
5db7afafb08d25b5fcdc5dc4cd2cdbe2
  $s$fToJSONf2 ::
    Data.Aeson.Types.ToJSON.ToJSON
      (HGit.Core.Types.Commit
         (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
         (Data.Functor.Const.Const
            Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit))
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (HGit.Core.Types.Commit
                       (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit))
                  (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                     @ (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                     (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                        @ (Type -> Type)
                        @ (HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                     (\ (x :: [Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash
                                 (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                      Data.Aeson.Types.Internal.$WArray
                        (Data.Vector.Generic.new
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Generic.New.unstream
                              @ Data.Vector.Vector
                              @ Data.Aeson.Types.Internal.Value
                              (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                              (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                 @ Data.Vector.Fusion.Util.Id
                                 @ Data.Aeson.Types.Internal.Value
                                 @ Data.Vector.Vector
                                 Data.Vector.Fusion.Util.$fMonadId
                                 Data.Vector.Fusion.Bundle.Size.Unknown
                                 (GHC.Base.build
                                    @ Data.Aeson.Types.Internal.Value
                                    (\ @ b1
                                       (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                       (n1 :: b1)[OneShot] ->
                                     GHC.Base.foldr
                                       @ (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash
                                            (HGit.Core.Types.Commit
                                               (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                       @ b1
                                       (GHC.Base.mapFB
                                          @ Data.Aeson.Types.Internal.Value
                                          @ b1
                                          @ (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash
                                               (HGit.Core.Types.Commit
                                                  (HGit.Core.Types.Hash
                                                     HGit.Core.Types.HashableDir)))
                                          c
                                          (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                             @ (Type -> Type)
                                             @ (HGit.Core.Types.Commit
                                                  (HGit.Core.Types.Hash
                                                     HGit.Core.Types.HashableDir))))
                                       n1
                                       x)))))))
                  (let {
                     g :: [Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash
                             (HGit.Core.Types.Commit
                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]
                          -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash
                                  (HGit.Core.Types.Commit
                                     (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir)))
                                           c
                                           (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir))))
                                        n1
                                        x)))))
                   } in
                   (\ (x :: HGit.Core.Types.Commit
                              (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)) ->
                    Data.Aeson.Encoding.Builder.encodeToBuilder
                      (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                         (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                         g
                         x))
                     `cast`
                   (<HGit.Core.Types.Commit
                       (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                       (Data.Functor.Const.Const
                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)>_R
                    ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                  <Data.Aeson.Types.Internal.Value>_P)))
                  (let {
                     f5 :: [Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash
                              (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = \ (x :: [Data.Functor.Const.Const
                                  Merkle.Types.IPFS.RawIPFSHash
                                  (HGit.Core.Types.Commit
                                     (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                       Data.Aeson.Types.Internal.$WArray
                         (Data.Vector.Generic.new
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Generic.New.unstream
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                  @ Data.Vector.Fusion.Util.Id
                                  @ Data.Aeson.Types.Internal.Value
                                  @ Data.Vector.Vector
                                  Data.Vector.Fusion.Util.$fMonadId
                                  Data.Vector.Fusion.Bundle.Size.Unknown
                                  (GHC.Base.build
                                     @ Data.Aeson.Types.Internal.Value
                                     (\ @ b1
                                        (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                        (n1 :: b1)[OneShot] ->
                                      GHC.Base.foldr
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                        @ b1
                                        (GHC.Base.mapFB
                                           @ Data.Aeson.Types.Internal.Value
                                           @ b1
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir)))
                                           c
                                           (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                              @ (Type -> Type)
                                              @ (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir))))
                                        n1
                                        x)))))
                   } in
                   let {
                     f1 :: HGit.Core.Types.Commit
                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                             (Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                           -> Data.Aeson.Types.Internal.Value
                       {- Arity: 1 -}
                     = HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                         @ (Data.Functor.Const.Const
                              Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                         (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                            @ (Type -> Type)
                            @ (HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                         f5
                   } in
                   \ (x :: [HGit.Core.Types.Commit
                              (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                              (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)]) ->
                   Data.Aeson.Types.Internal.$WArray
                     (Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n1 :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ (HGit.Core.Types.Commit
                                         (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                                         (Data.Functor.Const.Const
                                            Merkle.Types.IPFS.RawIPFSHash
                                            HGit.Core.Types.HashableCommit))
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ (HGit.Core.Types.Commit
                                            (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                                            (Data.Functor.Const.Const
                                               Merkle.Types.IPFS.RawIPFSHash
                                               HGit.Core.Types.HashableCommit))
                                       c
                                       f1)
                                    n1
                                    x))))))
                  (Data.Aeson.Encoding.Internal.list
                     @ (HGit.Core.Types.Commit
                          (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit))
                     (let {
                        g :: [Data.Functor.Const.Const
                                Merkle.Types.IPFS.RawIPFSHash
                                (HGit.Core.Types.Commit
                                   (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]
                             -> Data.Aeson.Types.Internal.Value
                          {- Arity: 1 -}
                        = \ (x :: [Data.Functor.Const.Const
                                     Merkle.Types.IPFS.RawIPFSHash
                                     (HGit.Core.Types.Commit
                                        (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                          Data.Aeson.Types.Internal.$WArray
                            (Data.Vector.Generic.new
                               @ Data.Vector.Vector
                               @ Data.Aeson.Types.Internal.Value
                               (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                               (Data.Vector.Generic.New.unstream
                                  @ Data.Vector.Vector
                                  @ Data.Aeson.Types.Internal.Value
                                  (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                                  (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                                     @ Data.Vector.Fusion.Util.Id
                                     @ Data.Aeson.Types.Internal.Value
                                     @ Data.Vector.Vector
                                     Data.Vector.Fusion.Util.$fMonadId
                                     Data.Vector.Fusion.Bundle.Size.Unknown
                                     (GHC.Base.build
                                        @ Data.Aeson.Types.Internal.Value
                                        (\ @ b1
                                           (c :: Data.Aeson.Types.Internal.Value
                                                 -> b1 -> b1)[OneShot]
                                           (n1 :: b1)[OneShot] ->
                                         GHC.Base.foldr
                                           @ (Data.Functor.Const.Const
                                                Merkle.Types.IPFS.RawIPFSHash
                                                (HGit.Core.Types.Commit
                                                   (HGit.Core.Types.Hash
                                                      HGit.Core.Types.HashableDir)))
                                           @ b1
                                           (GHC.Base.mapFB
                                              @ Data.Aeson.Types.Internal.Value
                                              @ b1
                                              @ (Data.Functor.Const.Const
                                                   Merkle.Types.IPFS.RawIPFSHash
                                                   (HGit.Core.Types.Commit
                                                      (HGit.Core.Types.Hash
                                                         HGit.Core.Types.HashableDir)))
                                              c
                                              (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                                 @ (Type -> Type)
                                                 @ (HGit.Core.Types.Commit
                                                      (HGit.Core.Types.Hash
                                                         HGit.Core.Types.HashableDir))))
                                           n1
                                           x)))))
                      } in
                      (\ (x :: HGit.Core.Types.Commit
                                 (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                                 (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash
                                    HGit.Core.Types.HashableCommit)) ->
                       Data.Aeson.Encoding.Builder.encodeToBuilder
                         (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                            @ (Data.Functor.Const.Const
                                 Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                            (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                               @ (Type -> Type)
                               @ (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                            g
                            x))
                        `cast`
                      (<HGit.Core.Types.Commit
                          (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
                          (Data.Functor.Const.Const
                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)>_R
                       ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                     <Data.Aeson.Types.Internal.Value>_P)))) -}
0002ba2cae3c5a83372693e1dafc8d04
  $s$fToJSONf_$ctoJSON ::
    HGit.Core.Types.Blob
      (Data.Functor.Const.Const
         Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1,
     Unfolding: InlineRule (0, True, False)
                (HGit.Core.Types.$fToJSON1Blob_$cliftToJSON
                   @ (Data.Functor.Const.Const
                        Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                   (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                      @ (Type -> Type)
                      @ HGit.Core.Types.Blob)
                   (\ (x :: [Data.Functor.Const.Const
                               Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob]) ->
                    Data.Aeson.Types.Internal.$WArray
                      (Data.Vector.Generic.new
                         @ Data.Vector.Vector
                         @ Data.Aeson.Types.Internal.Value
                         (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                         (Data.Vector.Generic.New.unstream
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                               @ Data.Vector.Fusion.Util.Id
                               @ Data.Aeson.Types.Internal.Value
                               @ Data.Vector.Vector
                               Data.Vector.Fusion.Util.$fMonadId
                               Data.Vector.Fusion.Bundle.Size.Unknown
                               (GHC.Base.build
                                  @ Data.Aeson.Types.Internal.Value
                                  (\ @ b1
                                     (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                     (n1 :: b1)[OneShot] ->
                                   GHC.Base.foldr
                                     @ (Data.Functor.Const.Const
                                          Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                     @ b1
                                     (GHC.Base.mapFB
                                        @ Data.Aeson.Types.Internal.Value
                                        @ b1
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                        c
                                        (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                           @ (Type -> Type)
                                           @ HGit.Core.Types.Blob))
                                     n1
                                     x))))))) -}
3857a5b31d0c29d6075ff648c44ac91a
  $s$fToJSONf_$ctoJSON1 ::
    HGit.Core.Types.Dir
      (HGit.Core.Types.Hash HGit.Core.Types.Blob)
      (Data.Functor.Const.Const
         Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <L,1*U(1*U)>m1,
     Unfolding: InlineRule (0, True, False)
                (HGit.Core.Types.$fToJSON1Dir_$cliftToJSON
                   @ (Data.Functor.Const.Const
                        Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                   (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                      @ (Type -> Type)
                      @ (HGit.Core.Types.Dir
                           (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                   (\ (x :: [Data.Functor.Const.Const
                               Merkle.Types.IPFS.RawIPFSHash
                               (HGit.Core.Types.Dir
                                  (HGit.Core.Types.Hash HGit.Core.Types.Blob))]) ->
                    Data.Aeson.Types.Internal.$WArray
                      (Data.Vector.Generic.new
                         @ Data.Vector.Vector
                         @ Data.Aeson.Types.Internal.Value
                         (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                         (Data.Vector.Generic.New.unstream
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                               @ Data.Vector.Fusion.Util.Id
                               @ Data.Aeson.Types.Internal.Value
                               @ Data.Vector.Vector
                               Data.Vector.Fusion.Util.$fMonadId
                               Data.Vector.Fusion.Bundle.Size.Unknown
                               (GHC.Base.build
                                  @ Data.Aeson.Types.Internal.Value
                                  (\ @ b1
                                     (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                     (n1 :: b1)[OneShot] ->
                                   GHC.Base.foldr
                                     @ (Data.Functor.Const.Const
                                          Merkle.Types.IPFS.RawIPFSHash
                                          (HGit.Core.Types.Dir
                                             (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                     @ b1
                                     (GHC.Base.mapFB
                                        @ Data.Aeson.Types.Internal.Value
                                        @ b1
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Dir
                                                (HGit.Core.Types.Hash HGit.Core.Types.Blob)))
                                        c
                                        (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                           @ (Type -> Type)
                                           @ (HGit.Core.Types.Dir
                                                (HGit.Core.Types.Hash HGit.Core.Types.Blob))))
                                     n1
                                     x))))))) -}
9a494280d3dff25aee31df352dd02a1c
  $s$fToJSONf_$ctoJSON2 ::
    HGit.Core.Types.Commit
      (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)
      (Data.Functor.Const.Const
         Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1,
     Unfolding: InlineRule (0, True, False)
                (HGit.Core.Types.$fToJSON1Commit_$cliftToJSON
                   @ (Data.Functor.Const.Const
                        Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                   (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                      @ (Type -> Type)
                      @ (HGit.Core.Types.Commit
                           (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                   (\ (x :: [Data.Functor.Const.Const
                               Merkle.Types.IPFS.RawIPFSHash
                               (HGit.Core.Types.Commit
                                  (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))]) ->
                    Data.Aeson.Types.Internal.$WArray
                      (Data.Vector.Generic.new
                         @ Data.Vector.Vector
                         @ Data.Aeson.Types.Internal.Value
                         (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                         (Data.Vector.Generic.New.unstream
                            @ Data.Vector.Vector
                            @ Data.Aeson.Types.Internal.Value
                            (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                            (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                               @ Data.Vector.Fusion.Util.Id
                               @ Data.Aeson.Types.Internal.Value
                               @ Data.Vector.Vector
                               Data.Vector.Fusion.Util.$fMonadId
                               Data.Vector.Fusion.Bundle.Size.Unknown
                               (GHC.Base.build
                                  @ Data.Aeson.Types.Internal.Value
                                  (\ @ b1
                                     (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                     (n1 :: b1)[OneShot] ->
                                   GHC.Base.foldr
                                     @ (Data.Functor.Const.Const
                                          Merkle.Types.IPFS.RawIPFSHash
                                          (HGit.Core.Types.Commit
                                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                     @ b1
                                     (GHC.Base.mapFB
                                        @ Data.Aeson.Types.Internal.Value
                                        @ b1
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash HGit.Core.Types.HashableDir)))
                                        c
                                        (Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON
                                           @ (Type -> Type)
                                           @ (HGit.Core.Types.Commit
                                                (HGit.Core.Types.Hash
                                                   HGit.Core.Types.HashableDir))))
                                     n1
                                     x))))))) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
b4f9ae97a091b232a88173a93240314d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
529073e95d7e97cca9b9c5c633464b51
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
3bd27e11144b62cbd3a7a1ae2df73fdc
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
"SPEC/Main $fFromJSONConst _ @ RawIPFSHash _" [orphan] forall @ k
                                                              @ b :: k
                                                              (v :: Data.Aeson.Types.FromJSON.FromJSON
                                                                      Merkle.Types.IPFS.RawIPFSHash)
  Data.Aeson.Types.FromJSON.$fFromJSONConst @ k
                                            @ Merkle.Types.IPFS.RawIPFSHash
                                            @ b
                                            v
  = Main.$s$fFromJSONConst @ k @ b
"SPEC/Main $fFromJSONf @ (Commit (Hash HashableDir)) @ (Const
                                                         RawIPFSHash HashableCommit)" [orphan] forall (v1 :: Data.Aeson.Types.FromJSON.FromJSON
                                                                                                                                                                             (Data.Functor.Const.Const
                                                                                                                                                                                Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                                                HGit.Core.Types.HashableCommit))
                                                                                                                                                                    (v :: Data.Aeson.Types.FromJSON.FromJSON1
                                                                                                                                                                            (HGit.Core.Types.Commit
                                                                                                                                                                               (HGit.Core.Types.Hash
                                                                                                                                                                                  HGit.Core.Types.HashableDir)))
  Data.Aeson.Orphans.$fFromJSONf @ (HGit.Core.Types.Commit
                                      (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                                 @ (Data.Functor.Const.Const
                                      Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                                 v
                                 v1
  = Main.$s$fFromJSONf2
"SPEC/Main $fFromJSONf @ (Dir (Hash Blob)) @ (Const
                                               RawIPFSHash HashableDir)" [orphan] forall (v1 :: Data.Aeson.Types.FromJSON.FromJSON
                                                                                                                                                      (Data.Functor.Const.Const
                                                                                                                                                         Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                         HGit.Core.Types.HashableDir))
                                                                                                                                             (v :: Data.Aeson.Types.FromJSON.FromJSON1
                                                                                                                                                     (HGit.Core.Types.Dir
                                                                                                                                                        (HGit.Core.Types.Hash
                                                                                                                                                           HGit.Core.Types.Blob)))
  Data.Aeson.Orphans.$fFromJSONf @ (HGit.Core.Types.Dir
                                      (HGit.Core.Types.Hash HGit.Core.Types.Blob))
                                 @ (Data.Functor.Const.Const
                                      Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                                 v
                                 v1
  = Main.$s$fFromJSONf1
"SPEC/Main $fFromJSONf @ Blob @ (Const RawIPFSHash Blob)" [orphan] forall (v1 :: Data.Aeson.Types.FromJSON.FromJSON
                                                                                   (Data.Functor.Const.Const
                                                                                      Merkle.Types.IPFS.RawIPFSHash
                                                                                      HGit.Core.Types.Blob))
                                                                          (v :: Data.Aeson.Types.FromJSON.FromJSON1
                                                                                  HGit.Core.Types.Blob)
  Data.Aeson.Orphans.$fFromJSONf @ HGit.Core.Types.Blob
                                 @ (Data.Functor.Const.Const
                                      Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                 v
                                 v1
  = Main.$s$fFromJSONf
"SPEC/Main $fToJSONConst_$ctoJSON _ @ RawIPFSHash _" [orphan] forall @ k
                                                                     @ b :: k
                                                                     ($dToJSON :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                    Merkle.Types.IPFS.RawIPFSHash)
  Data.Aeson.Types.ToJSON.$fToJSONConst_$ctoJSON @ k
                                                 @ Merkle.Types.IPFS.RawIPFSHash
                                                 @ b
                                                 $dToJSON
  = Main.$s$fToJSONConst_$s$fToJSONConst_$ctoJSON @ k @ b
"SPEC/Main $fToJSONf @ (Commit (Hash HashableDir)) @ (Const
                                                       RawIPFSHash HashableCommit)" [orphan] forall (v1 :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                                                                                                         (Data.Functor.Const.Const
                                                                                                                                                                            Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                                            HGit.Core.Types.HashableCommit))
                                                                                                                                                                (v :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                                                                                                        (HGit.Core.Types.Commit
                                                                                                                                                                           (HGit.Core.Types.Hash
                                                                                                                                                                              HGit.Core.Types.HashableDir)))
  Data.Aeson.Orphans.$fToJSONf @ (HGit.Core.Types.Commit
                                    (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                               @ (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableCommit)
                               v
                               v1
  = Main.$s$fToJSONf2
"SPEC/Main $fToJSONf @ (Dir (Hash Blob)) @ (Const
                                             RawIPFSHash HashableDir)" [orphan] forall (v1 :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                                                                                  (Data.Functor.Const.Const
                                                                                                                                                     Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                     HGit.Core.Types.HashableDir))
                                                                                                                                         (v :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                                                                                 (HGit.Core.Types.Dir
                                                                                                                                                    (HGit.Core.Types.Hash
                                                                                                                                                       HGit.Core.Types.Blob)))
  Data.Aeson.Orphans.$fToJSONf @ (HGit.Core.Types.Dir
                                    (HGit.Core.Types.Hash HGit.Core.Types.Blob))
                               @ (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.HashableDir)
                               v
                               v1
  = Main.$s$fToJSONf1
"SPEC/Main $fToJSONf @ Blob @ (Const RawIPFSHash Blob)" [orphan] forall (v1 :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                 (Data.Functor.Const.Const
                                                                                    Merkle.Types.IPFS.RawIPFSHash
                                                                                    HGit.Core.Types.Blob))
                                                                        (v :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                HGit.Core.Types.Blob)
  Data.Aeson.Orphans.$fToJSONf @ HGit.Core.Types.Blob
                               @ (Data.Functor.Const.Const
                                    Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                               v
                               v1
  = Main.$s$fToJSONf
"SPEC/Main $fToJSONf_$ctoJSON @ (Commit (Hash HashableDir)) @ (Const
                                                                RawIPFSHash HashableCommit)" [orphan] forall ($dToJSON :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                                                                                                                                 (Data.Functor.Const.Const
                                                                                                                                                                                                    Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                                                                    HGit.Core.Types.HashableCommit))
                                                                                                                                                                                  ($dToJSON1 :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                                                                                                                                  (HGit.Core.Types.Commit
                                                                                                                                                                                                     (HGit.Core.Types.Hash
                                                                                                                                                                                                        HGit.Core.Types.HashableDir)))
  Data.Aeson.Orphans.$fToJSONf_$ctoJSON @ (HGit.Core.Types.Commit
                                             (HGit.Core.Types.Hash HGit.Core.Types.HashableDir))
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             HGit.Core.Types.HashableCommit)
                                        $dToJSON1
                                        $dToJSON
  = Main.$s$fToJSONf_$ctoJSON2
"SPEC/Main $fToJSONf_$ctoJSON @ (Dir (Hash Blob)) @ (Const
                                                      RawIPFSHash HashableDir)" [orphan] forall ($dToJSON :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                                                                                                          (Data.Functor.Const.Const
                                                                                                                                                                             Merkle.Types.IPFS.RawIPFSHash
                                                                                                                                                                             HGit.Core.Types.HashableDir))
                                                                                                                                                           ($dToJSON1 :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                                                                                                           (HGit.Core.Types.Dir
                                                                                                                                                                              (HGit.Core.Types.Hash
                                                                                                                                                                                 HGit.Core.Types.Blob)))
  Data.Aeson.Orphans.$fToJSONf_$ctoJSON @ (HGit.Core.Types.Dir
                                             (HGit.Core.Types.Hash HGit.Core.Types.Blob))
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash
                                             HGit.Core.Types.HashableDir)
                                        $dToJSON1
                                        $dToJSON
  = Main.$s$fToJSONf_$ctoJSON1
"SPEC/Main $fToJSONf_$ctoJSON @ Blob @ (Const RawIPFSHash Blob)" [orphan] forall ($dToJSON :: Data.Aeson.Types.ToJSON.ToJSON
                                                                                                (Data.Functor.Const.Const
                                                                                                   Merkle.Types.IPFS.RawIPFSHash
                                                                                                   HGit.Core.Types.Blob))
                                                                                 ($dToJSON1 :: Data.Aeson.Types.ToJSON.ToJSON1
                                                                                                 HGit.Core.Types.Blob)
  Data.Aeson.Orphans.$fToJSONf_$ctoJSON @ HGit.Core.Types.Blob
                                        @ (Data.Functor.Const.Const
                                             Merkle.Types.IPFS.RawIPFSHash HGit.Core.Types.Blob)
                                        $dToJSON1
                                        $dToJSON
  = Main.$s$fToJSONf_$ctoJSON
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

